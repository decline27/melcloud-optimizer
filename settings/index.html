<!DOCTYPE html>
<html>
  <head>
    <script
      type="text/javascript"
      src="/homey.js"
      data-origin="settings"
    ></script>
    <style>
      .button-container {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 10px;
      }
      .result-message {
        margin-top: 10px;
        font-style: italic;
      }
      .homey-button-warning {
        background-color: #f5a623;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 8px 16px;
        cursor: pointer;
      }
      .homey-button-warning:hover {
        background-color: #e09612;
      }

      /* Accessible accordion styling */
      details.homey-form-fieldset {
        border: 1px solid #eee;
        border-radius: 6px;
        padding: 0;
        margin: 10px 0 14px;
        background: #fff;
      }
      details.homey-form-fieldset > summary.homey-form-legend {
        list-style: none;
        cursor: pointer;
        padding: 10px 12px;
        font-weight: 600;
        outline: none;
      }
      details.homey-form-fieldset[open] > summary.homey-form-legend {
        border-bottom: 1px solid #eee;
      }
      details.homey-form-fieldset .homey-form-group,
      details.homey-form-fieldset .homey-form-row {
        padding: 8px 12px;
      }
      .homey-form-error { color: #b00; margin-top: 4px; }
      .homey-form-group.disabled {
        opacity: 0.6;
        pointer-events: none;
      }

      .metric-row {
        display: flex;
        align-items: baseline;
        gap: 0.25rem;
        margin: 0.3rem 0;
      }

      .metric-label {
        font-weight: 600;
        margin-right: 0.25rem;
      }

      .tt-wrap {
        position: relative;
        display: inline-flex;
        align-items: center;
      }

      .tt-btn {
        margin-left: 0.25rem;
        width: 16px;
        height: 16px;
        line-height: 16px;
        font-size: 10px;
        border: 1px solid #cbd5e1;
        color: #475569;
        border-radius: 9999px;
        text-align: center;
        background: #fff;
        cursor: pointer;
        padding: 0;
      }

      .tt-bubble {
        position: absolute;
        left: 50%;
        bottom: 100%;
        transform: translateX(-50%);
        background: #111827;
        color: #fff;
        font-size: 12px;
        white-space: pre-wrap;
        padding: 0.35rem 0.5rem;
        border-radius: 0.4rem;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        margin-bottom: 0.35rem;
        z-index: 50;
        max-width: 280px;
        display: none;
      }

      .tt-wrap[data-open="true"] .tt-bubble {
        display: block;
      }

      @media (hover: hover) {
        .tt-wrap:hover .tt-bubble {
          display: block;
        }
      }
    </style>
  </head>
  <body>
    <header class="homey-header">
      <h1 class="homey-title">MELCloud Optimizer Settings</h1>
      <p class="homey-subtitle">Configure your credentials and temperature settings</p>
    </header>

    <details class="homey-form-fieldset" open>
      <summary class="homey-form-legend">Quick Start: MELCloud & Device</summary>
      <div class="homey-form-group">
        <label class="homey-form-label" for="melcloud_user">Email</label>
        <input class="homey-form-input" id="melcloud_user" type="email" autocomplete="username" aria-describedby="melcloud_user_help" value="" />
        <p id="melcloud_user_help" class="homey-form-helper">Use your MELCloud account email.</p>
      </div>
      <div class="homey-form-group">
        <label class="homey-form-label" for="melcloud_pass">Password</label>
        <input class="homey-form-input" id="melcloud_pass" type="password" autocomplete="current-password" aria-describedby="melcloud_pass_help" value="" />
        <p id="melcloud_pass_help" class="homey-form-helper">Stored securely by Homey.</p>
      </div>

      <div class="homey-form-group">
        <button id="refresh_devices" class="homey-button-primary">Refresh Device List</button>
        <span id="device_refresh_status" role="status" aria-live="polite"></span>
      </div>

      <div class="homey-form-group">
        <label class="homey-form-label" for="building_id">Building</label>
        <select class="homey-form-input" id="building_id">
          <option value="">Select a building</option>
        </select>
        <p class="homey-form-helper">Select your building from the dropdown or use Advanced to enter IDs manually.</p>
      </div>

      <div class="homey-form-group">
        <label class="homey-form-label" for="device_id">Device</label>
        <select class="homey-form-input" id="device_id">
          <option value="">Select a device</option>
        </select>
        <p class="homey-form-helper">Capabilities appear after selection; use Advanced for manual IDs.</p>
      </div>

      <div class="homey-form-group">
        <details>
          <summary class="homey-form-label">Advanced: Manual ID entry</summary>
          <label class="homey-form-checkbox">
            <input type="checkbox" id="show_manual_entry" />
            <span>Show manual ID entry fields</span>
          </label>
          <p class="homey-form-helper">This option only affects this page and is not saved.</p>
        </details>
      </div>

      <div id="manual_id_entry" style="display: none;">
        <div class="homey-form-group">
          <label class="homey-form-label" for="manual_device_id">Manual Device ID</label>
          <input class="homey-form-input" id="manual_device_id" type="text" value="" />
          <p class="homey-form-helper">The ID of your heat pump device in MELCloud (not stored; used only when saving)</p>
        </div>
        <div class="homey-form-group">
          <label class="homey-form-label" for="manual_building_id">Manual Building ID</label>
          <input class="homey-form-input" id="manual_building_id" type="text" value="" />
          <p class="homey-form-helper">The ID of the building (not stored; used only when saving)</p>
        </div>
      </div>

      <div class="homey-form-group">
        <label class="homey-form-label" for="time_zone_name">Time Zone (automatic DST handling)</label>
        <div class="timezone-input-container">
          <input
            class="homey-form-input"
            id="time_zone_name"
            type="text"
            list="time_zone_name_list"
            placeholder="e.g., Europe/Stockholm"
            autocomplete="off"
          />
          <button type="button" class="homey-button-secondary" id="detect_time_zone_name" style="margin-left: 8px;">Auto-detect</button>
        </div>
        <datalist id="time_zone_name_list"></datalist>
        <div class="timezone-info">
          <p class="homey-form-helper">
            <strong>‚úÖ Recommended:</strong> Use an IANA time zone like <code>Europe/Stockholm</code> for accurate DST handling.
            This automatically manages daylight saving time transitions.
          </p>
          <div id="timezone_preview" class="timezone-preview" style="display: none;">
            <p class="homey-form-helper" style="color: #007acc; font-weight: 500;">
              Current time in selected zone: <span id="timezone_preview_time"></span>
            </p>
          </div>
          <div id="migration_notice" class="migration-notice" style="display: none; background: #f0f8ff; padding: 12px; border-radius: 6px; margin: 8px 0;">
            <p style="margin: 0; color: #0066cc;">
              üí° <strong>Upgrade Available:</strong> You're currently using manual timezone settings. 
              <button type="button" id="convert_to_auto" class="homey-button-secondary" style="margin-left: 8px;">Convert to Automatic</button>
            </p>
          </div>
        </div>
        <span id="time_zone_name_status" class="homey-form-helper" aria-live="polite"></span>
        
        <style>
          .timezone-input-container {
            display: flex;
            align-items: center;
            gap: 8px;
          }
          
          .timezone-input-container input {
            flex: 1;
            margin: 0;
          }
          
          .timezone-preview {
            background: #f8fffe;
            border-left: 3px solid #00cc88;
            padding: 8px 12px;
            margin: 8px 0;
            border-radius: 4px;
          }
          
          .migration-notice {
            background: #f0f8ff;
            border-left: 3px solid #0066cc;
            padding: 12px;
            margin: 8px 0;
            border-radius: 4px;
          }
        </style>
      </div>
    </details>

    <details class="homey-form-fieldset" id="model_confidence_section">
      <summary class="homey-form-legend">Live Model Confidence</summary>
      <div class="homey-form-group">
        <p class="homey-form-helper">Read-only snapshot of the thermal model's learning state.</p>
      </div>
      
      <div class="homey-form-group" style="display: flex; justify-content: space-between; align-items: center;">
        <span></span>
        <button type="button" id="refresh_model_confidence" class="homey-button-secondary">Refresh</button>
      </div>

      <div id="model_confidence_loading" class="homey-form-group" style="display: none;">
        <p class="homey-form-helper" style="font-style: italic;">Loading model confidence data...</p>
      </div>

      <div id="model_confidence_content">
        <div class="homey-form-group" style="border: 1px solid #e0e0e0; border-radius: 6px; padding: 16px; background: #fafafa;">
          <div style="margin-bottom: 12px;">
            <span class="metric-label" style="font-weight: 600;" data-tooltip="How sure the optimizer is about its predictions. Increases as more data is collected.">Confidence:</span>
            <span id="model_confidence_value" style="font-size: 1.1em; margin-left: 8px;" aria-live="polite">‚Äî</span>
            <span id="model_confidence_status" style="margin-left: 8px; font-style: italic;">Learning‚Ä¶</span>
          </div>

          <div id="model_thermal_details" style="display: none; margin-top: 12px; padding-top: 12px; border-top: 1px solid #e0e0e0;">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 0.9em;">
              <div id="heating_rate_row" style="display: none;">
                <span class="metric-label" data-tooltip="How fast your home warms up when heating is active (¬∞C per hour).">Heating rate:</span>
                <span id="heating_rate_value" style="font-weight: 500; margin-left: 4px;">‚Äî</span>
              </div>
              <div id="cooling_rate_row" style="display: none;">
                <span class="metric-label" data-tooltip="How fast your home cools down when heating is off (¬∞C per hour).">Cooling rate:</span>
                <span id="cooling_rate_value" style="font-weight: 500; margin-left: 4px;">‚Äî</span>
              </div>
              <div id="thermal_mass_row" style="display: none;">
                <span class="metric-label" data-tooltip="How much heat your building stores. Higher = better heat retention and smoother control.">Thermal mass:</span>
                <span id="thermal_mass_value" style="font-weight: 500; margin-left: 4px;">‚Äî</span>
              </div>
            </div>
          </div>

          <div id="model_learning_details" style="display: none; margin-top: 12px; padding-top: 12px; border-top: 1px solid #e0e0e0;">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 0.9em;">
              <div id="last_calibration_row" style="display: none;">
                <span>Last updated:</span>
                <span id="last_calibration_value" style="font-weight: 500; margin-left: 4px;">‚Äî</span>
              </div>
              <div id="learning_cycles_row" style="display: none;">
                <span class="metric-label" data-tooltip="Each hourly optimization run that teaches the system about your home.">Learning cycles:</span>
                <span id="learning_cycles_value" style="font-weight: 500; margin-left: 4px;">‚Äî</span>
              </div>
            </div>
          </div>

          <div id="model_retention_details" style="display: none; margin-top: 12px; padding-top: 12px; border-top: 1px solid #e0e0e0;">
            <div style="font-size: 0.85em; color: #666;">
              <span>Data: </span>
              <span id="thermal_raw_points">‚Äî</span> raw /
              <span id="thermal_agg_points">‚Äî</span> agg ‚Ä¢
              <span id="thermal_total_kb">‚Äî</span> KB
            </div>
          </div>

          <!-- System Learning Overview (read-only) -->
          <div id="sys-learning-overview" style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e0e0e0;">
            <div style="font-weight: 600; margin-bottom: 6px;">System Learning Overview</div>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 0.9em;">
              <li id="slo-temp" aria-live="polite" style="margin-bottom: 8px;">
                <div>‚Ä¢ Temperature model: <span class="value">Learning</span></div>
                <div class="detail" style="font-size: 0.85em; color: #666; margin-left: 12px; margin-top: 2px;">‚Äî</div>
              </li>
              <li id="slo-price" aria-live="polite" style="margin-bottom: 8px;">
                <div>‚Ä¢ <span class="metric-label" data-tooltip="Reliability of cheap/normal/expensive classification used in planning.">Price strategy:</span> <span class="value">Learning</span></div>
                <div class="detail" style="font-size: 0.85em; color: #666; margin-left: 12px; margin-top: 2px;">‚Äî</div>
              </li>
              <li id="slo-hw" aria-live="polite" style="margin-bottom: 4px;">
                <div>‚Ä¢ <span class="metric-label" data-tooltip="Confidence in your daily hot-water usage pattern.">Hot water forecast:</span> <span class="value">Learning</span></div>
                <div class="detail" style="font-size: 0.85em; color: #666; margin-left: 12px; margin-top: 2px;">‚Äî</div>
              </li>
            </ul>
          </div>

          <!-- Estimated Smart Savings (read-only) -->
          <div id="smart-savings-card" style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e0e0e0;">
            <div style="font-weight: 600; margin-bottom: 6px;">Estimated Smart Savings (vs traditional heat pump)</div>
            <div style="font-size: 0.9em;">
              <div aria-live="polite" style="margin-bottom: 8px;">
                <strong class="metric-label" data-tooltip="Estimated savings today vs a traditional always-on heat pump.">Today:</strong> <span id="smart-savings-today" style="font-weight: 500;">‚Äî</span>
              </div>
              <div aria-live="polite" style="margin-bottom: 8px;">
                <strong class="metric-label" data-tooltip="Estimated savings summed over the last 7 days.">Last 7 days:</strong> <span id="smart-savings-7d" style="font-weight: 500;">‚Äî</span>
              </div>
              <div aria-live="polite" style="margin-bottom: 8px;">
                <strong class="metric-label" data-tooltip="Projected monthly savings based on current patterns.">Projection:</strong> <span id="smart-savings-projection" style="font-weight: 500;">‚Äî</span>
              </div>
              <div aria-live="polite" style="margin-bottom: 4px;">
                <strong class="metric-label" data-tooltip="Current seasonal profile used to tune comfort vs efficiency.">Season mode:</strong> <span id="smart-savings-season" style="font-weight: 500;">‚Äî</span>
              </div>
            </div>
            <div id="smart-savings-chart-header" class="row" style="display:flex;align-items:center;justify-content:space-between;margin-top:8px;">
              <div class="muted" style="font-size:0.9em;">Savings history</div>
              <div role="group" aria-label="Range" style="display:flex;gap:6px;">
                <button id="ss-range-7" type="button" class="btn btn-ghost btn-xs" aria-pressed="true">7d</button>
                <button id="ss-range-30" type="button" class="btn btn-ghost btn-xs" aria-pressed="false">30d</button>
              </div>
            </div>
            <div id="smart-savings-chart-wrap" style="margin:6px 0 10px;">
              <svg id="smart-savings-chart" viewBox="0 0 320 80" preserveAspectRatio="none" role="img" aria-label="Savings over time"></svg>
              <div id="smart-savings-chart-empty" class="muted" style="display:none;font-size:0.9em;">No savings history yet.</div>
            </div>
            <details id="smart-savings-why" style="margin-top:4px;">
              <summary style="cursor:pointer;font-weight:600;">üí° Why these savings?</summary>
              <div class="muted" style="margin-top:6px;font-size:0.92em;line-height:1.35;">
                These values estimate how much you save versus a traditional heat pump that keeps a constant setpoint and ignores price and weather.
                We compare that baseline to your smart operation that shifts heating to cheaper hours and adapts to seasons.
                <br/><br/>
                <strong>What‚Äôs included:</strong> real electricity prices, seasonal COP adjustments, hot-water usage patterns, and the thermal model‚Äôs
                expected energy for a fixed-setpoint baseline. <em>Display-only:</em> this does not change any optimizer decisions.
              </div>
            </details>
            <div id="smart-savings-note" style="font-size: 0.85em; color: #666; margin-top: 6px;"></div>
          </div>

          <div id="model_empty_state" class="homey-form-helper" style="margin-top: 12px; font-style: italic; color: #666;">
            Model builds confidence as your system runs normal heating cycles.
          </div>

          <div id="model_error_state" style="display: none; margin-top: 12px; color: #d32f2f; font-size: 0.9em;">
            <span id="model_error_message">‚Äî</span>
          </div>
        </div>
      </div>
    </details>

    <details class="homey-form-fieldset">
      <summary class="homey-form-legend">Electricity Price Source</summary>
      <div class="homey-form-group">
        <p class="homey-form-helper">Choose which provider supplies hourly electricity prices. Tibber requires your own API token, while ENTSO-E uses the bundled token and zone settings.</p>
      </div>
      <div class="homey-form-group">
        <label class="homey-form-checkbox">
          <input type="radio" name="price_source" id="price_source_tibber" value="tibber" />
          <span>Use Tibber API (personal token required)</span>
        </label>
      </div>
      <div class="homey-form-group">
        <label class="homey-form-checkbox">
          <input type="radio" name="price_source" id="price_source_entsoe" value="entsoe" checked />
          <span>Use ENTSO-E day-ahead prices (bundled token)</span>
        </label>
      </div>
      <div class="homey-form-group">
        <span class="homey-form-helper" id="price_source_status"></span>
      </div>
    </details>

    <details class="homey-form-fieldset" id="entsoe_quick_settings">
      <summary class="homey-form-legend">ENTSO-E Zone (Quick)</summary>
      <div class="homey-form-group">
        <label class="homey-form-label" for="entsoe_zone_input">ISO or EIC</label>
        <input class="homey-form-input" id="entsoe_zone_input" type="text" placeholder="SE3 or 10Y1001A1001A46L" autocomplete="off" value="SE3" />
        <p class="homey-form-helper">This value is stored as <code>entsoe_area_eic</code>. Use ISO (country/area) or a full EIC. For the full selector and map editor open the ENTSO-E Pricing section below.</p>
      </div>
      <div class="homey-form-group">
        <button type="button" class="homey-button-secondary" id="entsoe_auto_detect">Auto-detect from locale</button>
        <button type="button" class="homey-button-secondary" id="entsoe_open_full" aria-expanded="false">Open full ENTSO-E settings</button>
      </div>
      <div class="homey-form-group" id="entsoe_full_container" hidden>
        <iframe
          id="entsoe_full_frame"
          title="ENTSO-E detailed settings"
          style="width: 100%; min-height: 600px; border: 1px solid var(--homey-border-color, #d0d7e2); border-radius: 8px;"
        ></iframe>
      </div>
      <div class="homey-form-group">
        <span class="homey-form-helper" id="entsoe_zone_status" aria-live="polite"></span>
      </div>
    </details>

    <details class="homey-form-fieldset">
      <summary class="homey-form-legend">Connection: Tibber API</summary>
      <div class="homey-form-group">
        <label class="homey-form-label" for="tibber_token">API Token</label>
        <input class="homey-form-input" id="tibber_token" type="password" value="" />
        <p class="homey-form-helper">Get your token from <a href="https://developer.tibber.com/" target="_blank">https://developer.tibber.com/</a></p>
      </div>
    </details>



    <details class="homey-form-fieldset" id="zone2_fieldset">
      <summary class="homey-form-legend">Device: Zone 2 Temperature</summary>
      <div class="homey-form-group">
        <label class="homey-form-label" for="enable_zone2">Enable Zone 2 Control</label>
        <label class="homey-form-checkbox">
          <input type="checkbox" id="enable_zone2" />
          <span>Enable optimization of Zone 2 temperature</span>
        </label>
        <p class="homey-form-helper">Enable separate temperature control for Zone 2 (if your device supports it)</p>
      </div>

      <div id="zone2_settings" style="display: none;">
        <div class="homey-form-group">
          <label class="homey-form-label" for="min_temp_zone2">Minimum Temperature Zone 2 (¬∞C)</label>
          <input class="homey-form-input" id="min_temp_zone2" type="number" min="16" max="22" step="0.5" value="18" />
        </div>
        <div class="homey-form-group">
          <label class="homey-form-label" for="max_temp_zone2">Maximum Temperature Zone 2 (¬∞C)</label>
          <input class="homey-form-input" id="max_temp_zone2" type="number" min="20" max="26" step="0.5" value="24" />
        </div>
        <div class="homey-form-group">
          <label class="homey-form-label" for="temp_step_zone2">Maximum Temperature Step Zone 2 (¬∞C)</label>
          <input class="homey-form-input" id="temp_step_zone2" type="number" min="0.1" max="2.0" step="0.1" value="0.5" />
          <p class="homey-form-helper">Controls how much the Zone 2 temperature can change in one step.</p>
        </div>
      </div>
    </details>

    <!-- Comfort & Safety Settings -->
    <details class="homey-form-fieldset" id="engine_fieldset" open>
      <summary class="homey-form-legend">Comfort & Stability</summary>

      <div class="homey-form-group">
        <div style="background:#f7fbff;border:1px solid #dbe9ff;border-radius:6px;padding:10px;">
          <div style="font-weight:600;margin-bottom:6px;">How optimisation saves money</div>
          <div class="homey-form-helper" style="margin:0;">
            ‚Ä¢ Shifts heating to cheap hours (preheat), coasts in expensive hours.<br>
            ‚Ä¢ Keeps comfort within a band (occupied vs away).<br>
            ‚Ä¢ Reduces compressor cycling with a deadband and a minimum interval between changes.<br>
            ‚Ä¢ Applies weather context (for example, warm trend ‚Üí smaller targets).
          </div>
        </div>
      </div>

      <div class="homey-form-group">
        <label class="homey-form-label">Safety & Stability</label>
        <div class="homey-form-row">
          <div class="homey-form-col">
            <label class="homey-form-label" for="deadband_c">Deadband (¬∞C)</label>
            <input class="homey-form-input" id="deadband_c" type="number" min="0.1" max="2.0" step="0.1" value="0.3" />
            <p class="homey-form-helper">Small window around target to avoid jitter. Suggested default: <b>0.3¬∞C</b>.</p>
            <p class="homey-form-helper">Impact: Larger deadband = fewer changes and less cycling (smoother), but slower fine‚Äëtuning. Typical range 0.3‚Äì0.5¬∞C.</p>
          </div>
          <div class="homey-form-col">
            <label class="homey-form-label" for="min_setpoint_change_minutes">Min Setpoint Interval (min)</label>
            <input class="homey-form-input" id="min_setpoint_change_minutes" type="number" min="5" max="180" step="5" value="30" />
            <p class="homey-form-helper">Anti‚Äìshort‚Äëcycling lockout between changes. Suggested default: <b>5 minutes</b>.</p>
            <p class="homey-form-helper">Impact: Higher values reduce compressor starts and avoid fighting defrost cycles; too high can slow reactions to big price swings.</p>
          </div>
          <div class="homey-form-col">
            <label class="homey-form-label" for="temp_step_max">Temperature Step (¬∞C)</label>
            <input class="homey-form-input" id="temp_step_max" type="number" min="0.5" max="1.0" step="0.5" value="0.5" />
            <p class="homey-form-helper">Max temperature change per optimization step. Suggested default: <b>0.5¬∞C</b>.</p>
            <p class="homey-form-helper">Impact: 1.0¬∞C reduces heat pump strain but slower fine-tuning. 0.5¬∞C provides finer control.</p>
          </div>
        </div>
        <div class="homey-form-row">
          <div class="homey-form-col">
            <label class="homey-form-label" for="extreme_weather_min_temp">Extreme Cold Min (¬∞C)</label>
            <input class="homey-form-input" id="extreme_weather_min_temp" type="number" min="16" max="23" step="0.5" value="20" />
            <p class="homey-form-helper">Minimum indoor target during deep cold. Suggested default: <b>20¬∞C</b>.</p>
            <p class="homey-form-helper">Impact: Protects comfort/COP during cold snaps (prevents over‚Äësetbacks). Increase if your home cools quickly.</p>
          </div>
        </div>
        <p class="homey-form-helper">Overall min/max targets now follow the lowest and highest comfort band values. Adjust the comfort bands below to tighten or widen that range.</p>
      </div>

      <div class="homey-form-group">
        <label class="homey-form-label">Comfort Bands</label>
        <div class="homey-form-row">
          <div class="homey-form-col">
            <label class="homey-form-checkbox">
              <input type="checkbox" id="occupied" checked />
              <span>Home is occupied</span>
            </label>
            <p class="homey-form-helper">Use occupied band; turn off for away band. Can be automated via Flows. Suggested default: <b>Enabled</b>.</p>
          </div>
        </div>
        <div class="homey-form-row">
          <div class="homey-form-col">
            <label class="homey-form-label" for="comfort_lower_occupied">Occupied Lower (¬∞C)</label>
            <input class="homey-form-input" id="comfort_lower_occupied" type="number" min="18" max="23" step="0.5" value="20" />
            <p class="homey-form-helper">Suggested default: <b>20.0¬∞C</b>.</p>
            <p class="homey-form-helper">Impact: Lower values increase savings in expensive hours but feel cooler. Adjust to your comfort.</p>
          </div>
          <div class="homey-form-col">
            <label class="homey-form-label" for="comfort_upper_occupied">Occupied Upper (¬∞C)</label>
            <input class="homey-form-input" id="comfort_upper_occupied" type="number" min="19" max="24" step="0.5" value="21" />
            <p class="homey-form-helper">Suggested default: <b>21.0¬∞C</b>.</p>
            <p class="homey-form-helper">Impact: Higher values allow more preheating in cheap hours (store heat), improving savings when a price spike is coming.</p>
          </div>
        </div>
        <div class="homey-form-row">
          <div class="homey-form-col">
            <label class="homey-form-label" for="comfort_lower_away">Away Lower (¬∞C)</label>
            <input class="homey-form-input" id="comfort_lower_away" type="number" min="17" max="22" step="0.5" value="19" />
            <p class="homey-form-helper">Suggested default: <b>19.0¬∞C</b>.</p>
            <p class="homey-form-helper">Impact: Away band reduces cost when nobody‚Äôs home; keep within safe bounds for building/frost protection.</p>
          </div>
          <div class="homey-form-col">
            <label class="homey-form-label" for="comfort_upper_away">Away Upper (¬∞C)</label>
            <input class="homey-form-input" id="comfort_upper_away" type="number" min="18" max="23" step="0.5" value="20.5" />
            <p class="homey-form-helper">Suggested default: <b>20.5¬∞C</b>.</p>
            <p class="homey-form-helper">Tip: Keep a 0.8‚Äì1.5¬∞C spread between lower/upper for stable control.</p>
          </div>
        </div>
      </div>

      <div class="homey-form-group">
        <label class="homey-form-label">Price‚ÄëAware Preheating</label>
        <label class="homey-form-checkbox">
          <input type="checkbox" id="preheat_enable" checked />
          <span>Enable preheating in cheap hours</span>
        </label>
        <p class="homey-form-helper">Suggested default: <b>Enabled</b>. Builds thermal buffer during low-price hours for use during peaks.</p>
        <div class="homey-form-row">
          <div class="homey-form-col">
            <label class="homey-form-label" for="preheat_horizon_hours">Horizon (hours)</label>
            <input class="homey-form-input" id="preheat_horizon_hours" type="number" min="6" max="36" step="1" value="12" />
            <p class="homey-form-helper">How far ahead to evaluate prices. Suggested default: <b>12 hours</b>.</p>
            <p class="homey-form-helper">Impact: Longer horizon anticipates evening spikes earlier; too long can include noisy data. Try 12‚Äì24h.</p>
          </div>
          <div class="homey-form-col">
            <label class="homey-form-label" for="preheat_cheap_percentile">Cheap percentile (0‚Äì1)</label>
            <input class="homey-form-input" id="preheat_cheap_percentile" type="number" min="0.05" max="0.5" step="0.05" value="0.25" />
            <p class="homey-form-helper">Treat hours at or below this percentile as cheap. Suggested default: <b>0.25</b> (25th percentile).</p>
            <p class="homey-form-helper">Impact: Lower values preheat only in the very cheapest hours (more selective). Higher values preheat more often.</p>
          </div>
        </div>
        <p class="homey-form-helper">Note: Some devices set to Flow/Curve modes may ignore room target changes. The Engine still optimizes within your comfort band, but the unit may apply targets via heating curve.</p>
      </div>
    </details>

    <details class="homey-form-fieldset" id="tank_fieldset">
      <summary class="homey-form-legend">Hot Water Tank</summary>
      <div class="homey-form-group">
        <label class="homey-form-label" for="enable_tank_control">Enable Hot Water Tank Control</label>
        <label class="homey-form-checkbox">
          <input type="checkbox" id="enable_tank_control" checked />
          <span>Enable optimization of hot water tank temperature</span>
        </label>
        <p class="homey-form-helper">Enable optimization of hot water tank temperature based on electricity prices. Suggested default: Enabled - allows the system to store hot water as thermal energy when electricity is cheap.</p>
        <p class="homey-form-helper">Impact: Shifts DHW heating to cheap hours (with whole degree steps for stability). Min/Max protect comfort and legionella schedules.</p>
        <p id="tank_capability_warning" class="homey-form-helper" style="display:none;color:#b00;">This device may not support tank water temperature control. If unsupported, these settings have no effect.</p>
      </div>
      <div class="homey-form-group">
        <label class="homey-form-label" for="min_tank_temp">Minimum Tank Temperature (¬∞C)</label>
        <input class="homey-form-input" id="min_tank_temp" type="number" min="30" max="45" step="1" value="40" />
        <p class="homey-form-helper">Minimum allowed temperature for the hot water tank. Suggested default: 41¬∞C - ensures sufficient hot water is always available while allowing for price optimization.</p>
      </div>
      <div class="homey-form-group">
        <label class="homey-form-label" for="max_tank_temp">Maximum Tank Temperature (¬∞C)</label>
        <input class="homey-form-input" id="max_tank_temp" type="number" min="40" max="60" step="1" value="50" />
        <p class="homey-form-helper">Maximum allowed temperature for the hot water tank. Suggested default: 53¬∞C - provides good thermal storage capacity without excessive energy use. Check your heat pump's maximum recommended tank temperature.</p>
      </div>
      <div class="homey-form-group">
        <label class="homey-form-label" for="tank_temp_step">Tank Temperature Step (¬∞C)</label>
        <input class="homey-form-input" id="tank_temp_step" type="number" min="1.0" max="5.0" step="1.0" value="1.0" />
        <p class="homey-form-helper">Maximum change in tank temperature per optimization cycle. Must be whole degrees only (1¬∞C, 2¬∞C, etc.). Suggested default: 2¬∞C - allows for meaningful temperature adjustments without causing excessive cycling of the heat pump.</p>
      </div>
    </details>

    <details class="homey-form-fieldset">
      <summary class="homey-form-legend">Hot Water Usage Patterns</summary>
      <div class="button-container">
        <button id="view_patterns" class="homey-button" onclick="viewHotWaterPatterns()">View Usage Patterns</button>
        <button id="reset_patterns" class="homey-button" onclick="resetHotWaterPatterns()">Reset Usage Patterns</button>
        <button id="clear_keep_patterns" class="homey-button-warning" onclick="clearHotWaterData(true)">Clear Data (Keep Patterns)</button>
        <button id="clear_all_data" class="homey-button-danger" onclick="clearHotWaterData(false)">Clear All Data</button>
      </div>
      <p class="homey-form-helper">View Usage Patterns: Dumps current learned patterns to the terminal/logs.<br>Reset Usage Patterns: Resets learned patterns to default values.<br>Clear Data (Keep Patterns): Removes detailed data points but keeps aggregated usage patterns.<br>Clear All Data: Removes all collected usage data and resets patterns.</p>
      <p id="hot_water_action_result" class="result-message"></p>
    </details>

    <details class="homey-form-fieldset">
      <summary class="homey-form-legend">Notifications</summary>
      <div class="homey-form-group">
        <label class="homey-form-label" for="notify_on_success">Notify On Success</label>
        <label class="homey-form-checkbox">
          <input type="checkbox" id="notify_on_success" />
          <span>Send a notification when optimization/calibration succeeds</span>
        </label>
        <p class="homey-form-helper">When enabled, you will receive a Homey notification for successful hourly optimization and weekly calibration.</p>
      </div>

      <div class="homey-form-group">
        <label class="homey-form-label" for="timeline_verbosity">Timeline Detail</label>
        <select class="homey-form-input" id="timeline_verbosity">
          <option value="minimal">Minimal - Daily savings + key actions</option>
          <option value="standard" selected>Standard - Hourly summary, friendly phrasing</option>
          <option value="detailed">Detailed - All hourly actions + parameters</option>
          <option value="debug" id="timeline_debug_option" style="display: none;">Developer debug - Raw engine text for troubleshooting</option>
        </select>
        <p class="homey-form-helper">Controls how much detail appears in timeline posts. Standard is recommended for most users.</p>
      </div>
    </details>

    <details class="homey-form-fieldset">
      <summary class="homey-form-legend">Localization</summary>
      <div class="homey-form-group">
        <label class="homey-form-label" for="currency_code">Currency (ISO 4217)</label>
        <input class="homey-form-input" id="currency_code" type="text" placeholder="e.g., NOK, SEK, EUR" value="EUR" />
        <p class="homey-form-helper">Optional. Overrides automatic currency detection for timeline messages. Use a 3-letter code (e.g., NOK, SEK, EUR, DKK, USD).</p>
      </div>
    </details>

    <details class="homey-form-fieldset">
      <summary class="homey-form-legend">Costs & Consumption</summary>
      <div class="homey-form-group">
        <label class="homey-form-label" for="grid_fee_per_kwh">Grid Fee (per kWh)</label>
        <input class="homey-form-input" id="grid_fee_per_kwh" type="number" min="0" step="0.01" placeholder="e.g., 1.04" />
        <p class="homey-form-helper">Optional. Adds your local grid fee to the electricity price when calculating savings. Example: 1.04 SEK/kWh.</p>
      </div>

      <div class="homey-form-group" id="consumer_markup_section" style="display: none;">
        <label class="homey-form-label">
          <input type="checkbox" id="enable_consumer_markup" />
          <span>Convert ENTSO-E wholesale to consumer prices</span>
        </label>
        <p class="homey-form-helper">Add taxes, grid fees, and markup to ENTSO-E wholesale prices to approximate consumer prices.</p>
      </div>

      <div class="homey-form-group" id="consumer_markup_config_section" style="display: none;">
        <label class="homey-form-label" for="consumer_markup_config">Consumer Price Components (JSON)</label>
        <textarea class="homey-form-input" id="consumer_markup_config" rows="12" placeholder="Consumer markup configuration..."></textarea>
        <p class="homey-form-helper">Configure grid fees, taxes, and markup by country. Includes defaults for 33+ European markets. <button type="button" class="homey-button-secondary" id="load_markup_defaults">Load Defaults</button></p>
        <div id="consumer_markup_status" class="homey-form-helper" style="color: #666; font-style: italic;"></div>
      </div>

      <div class="homey-form-group" id="markup_currency_section" style="display: none;">
        <label class="homey-form-label" for="markup_currency_unit">Markup Values Currency</label>
        <select class="homey-form-input" id="markup_currency_unit">
          <option value="LOCAL">Auto-detect from Homey settings</option>
          <option value="EUR">Euro (EUR)</option>
          <option value="SEK">Swedish Krona (SEK)</option>
          <option value="NOK">Norwegian Krone (NOK)</option>
          <option value="DKK">Danish Krone (DKK)</option>
          <option value="PLN">Polish Z≈Çoty (PLN)</option>
          <option value="CZK">Czech Koruna (CZK)</option>
          <option value="HUF">Hungarian Forint (HUF)</option>
          <option value="RON">Romanian Leu (RON)</option>
          <option value="BGN">Bulgarian Lev (BGN)</option>
          <option value="HRK">Croatian Kuna (HRK)</option>
          <option value="CHF">Swiss Franc (CHF)</option>
          <option value="GBP">British Pound (GBP)</option>
        </select>
        <p class="homey-form-helper">Currency used for grid fees, taxes, and markup values in the JSON configuration above. If values are in different currencies, they'll be converted to your Homey currency automatically.</p>
      </div>
    </details>

    <details class="homey-form-fieldset">
      <summary class="homey-form-legend">Weather & Location</summary>
      <div class="homey-form-group">
        <label class="homey-form-label" for="use_weather_data">Use Weather Data</label>
        <label class="homey-form-checkbox">
          <input type="checkbox" id="use_weather_data" checked />
          <span>Enable weather data integration (Met.no API)</span>
        </label>
        <p class="homey-form-helper">Uses weather data to improve temperature optimization based on outdoor conditions</p>
      </div>

      <div class="homey-form-group">
        <label class="homey-form-label" for="weather_location">Your Location</label>
        <div class="homey-form-row">
          <div class="homey-form-col">
            <label class="homey-form-label" for="latitude">Latitude</label>
            <input class="homey-form-input" id="latitude" type="number" step="0.000001" placeholder="e.g., 51.5074" />
            <p class="homey-form-helper">Decimal degrees (e.g., 51.5074 for London)</p>
          </div>
          <div class="homey-form-col">
            <label class="homey-form-label" for="longitude">Longitude</label>
            <input class="homey-form-input" id="longitude" type="number" step="0.000001" placeholder="e.g., -0.1278" />
            <p class="homey-form-helper">Decimal degrees (e.g., -0.1278 for London)</p>
          </div>
        </div>
        <button id="detect-location" class="homey-button-primary">Detect My Location</button>
        <p class="homey-form-helper">You can find your coordinates using <a href="https://www.latlong.net/" target="_blank">LatLong.net</a> or similar services</p>
        <p id="weather_location_warning" class="homey-form-helper" style="display:none;color:#b00;">Weather is enabled but coordinates are missing. Set latitude and longitude for accurate weather optimization.</p>
      </div>
    </details>

    <details class="homey-form-fieldset">
      <summary class="homey-form-legend">Schedule & Time</summary>
      <div class="homey-form-group">
        <label class="homey-form-label">Day Profile (Higher Comfort)</label>
        <div class="homey-form-row">
          <div class="homey-form-col">
            <label class="homey-form-label" for="day_start_hour">Start Hour</label>
            <input class="homey-form-input" id="day_start_hour" type="number" min="0" max="23" step="1" value="6" />
            <p class="homey-form-helper">Hour when day profile begins (0-23)</p>
          </div>
          <div class="homey-form-col">
            <label class="homey-form-label" for="day_end_hour">End Hour</label>
            <input class="homey-form-input" id="day_end_hour" type="number" min="0" max="23" step="1" value="22" />
            <p class="homey-form-helper">Hour when day profile ends (0-23)</p>
          </div>
        </div>
      </div>

      <div class="homey-form-group">
        <label class="homey-form-label">Temperature Adjustments</label>
        <div class="homey-form-row">
          <div class="homey-form-col">
            <label class="homey-form-label" for="night_temp_reduction">Night Reduction</label>
            <input class="homey-form-input" id="night_temp_reduction" type="number" min="0" max="5" step="0.5" value="2" />
            <p class="homey-form-helper">Temperature reduction during night (¬∞C)</p>
          </div>
          <div class="homey-form-col">
            <label class="homey-form-label" for="pre_heat_hours">Pre-heat Hours</label>
            <input class="homey-form-input" id="pre_heat_hours" type="number" min="0" max="3" step="0.5" value="1" />
            <p class="homey-form-helper">Hours before day start to begin pre-heating</p>
          </div>
        </div>
      </div>

      <details class="homey-form-fieldset" style="margin-top: 20px;">
        <summary class="homey-form-legend">‚öôÔ∏è Advanced: Manual Timezone (deprecated)</summary>
        <div class="homey-form-group" style="background: #fff8dc; padding: 12px; border-radius: 6px; margin: 12px 0;">
          <p style="margin: 0; color: #b8860b; font-weight: 500;">
            ‚ö†Ô∏è <strong>Deprecated:</strong> Manual timezone settings are less accurate than IANA timezones. 
            We recommend using the automatic timezone setting above for better DST handling.
          </p>
        </div>
        
        <div class="homey-form-group">
          <label class="homey-form-label">Manual Time Zone Override</label>
          <div class="homey-form-row">
            <div class="homey-form-col">
              <label class="homey-form-label" for="time_zone_offset">UTC Offset</label>
              <select class="homey-form-input" id="time_zone_offset">
                <option value="-12">UTC-12:00</option>
                <option value="-11">UTC-11:00</option>
                <option value="-10">UTC-10:00</option>
                <option value="-9">UTC-09:00</option>
                <option value="-8">UTC-08:00</option>
                <option value="-7">UTC-07:00</option>
                <option value="-6">UTC-06:00</option>
                <option value="-5">UTC-05:00</option>
                <option value="-4">UTC-04:00</option>
                <option value="-3">UTC-03:00</option>
                <option value="-2">UTC-02:00</option>
                <option value="-1">UTC-01:00</option>
                <option value="0">UTC+00:00</option>
                <option value="1" selected>UTC+01:00</option>
                <option value="2">UTC+02:00</option>
                <option value="3">UTC+03:00</option>
                <option value="4">UTC+04:00</option>
                <option value="5">UTC+05:00</option>
                <option value="5.5">UTC+05:30</option>
                <option value="6">UTC+06:00</option>
                <option value="7">UTC+07:00</option>
                <option value="8">UTC+08:00</option>
                <option value="9">UTC+09:00</option>
                <option value="9.5">UTC+09:30</option>
                <option value="10">UTC+10:00</option>
                <option value="11">UTC+11:00</option>
                <option value="12">UTC+12:00</option>
                <option value="13">UTC+13:00</option>
              </select>
              <p class="homey-form-helper">Only used if IANA timezone above is empty</p>
            </div>
            <div class="homey-form-col">
              <label class="homey-form-label" for="use_dst">Daylight Saving Time</label>
              <label class="homey-form-checkbox">
                <input type="checkbox" id="use_dst" checked />
                <span>Manually adjust for DST</span>
              </label>
              <p class="homey-form-helper">Manual DST adjustment (less accurate than IANA)</p>
            </div>
          </div>
        </div>
      </details>
    </details>

    <details class="homey-form-fieldset">
      <summary class="homey-form-legend">COP Optimization</summary>
      <div class="homey-form-group">
        <label class="homey-form-label" for="cop_weight">COP Weight Factor</label>
        <input class="homey-form-input" id="cop_weight" type="number" min="0.0" max="1.0" step="0.05" value="0.3" />
        <p class="homey-form-helper">Weight given to COP (Coefficient of Performance) in optimization. Suggested default: 0.3 - balanced approach that considers both price and efficiency. Higher values (0.5-0.8) prioritize energy efficiency over price savings, while lower values (0.1-0.2) prioritize price savings over efficiency. For maximum cost savings, use 0.0-0.1.</p>
      </div>
      <div class="homey-form-group">
        <label class="homey-form-label" for="auto_seasonal_mode">Seasonal Mode Settings</label>
        <label class="homey-form-checkbox">
          <input type="checkbox" id="auto_seasonal_mode" checked />
          <span>Auto Seasonal Mode</span>
        </label>
        <p class="homey-form-helper">Automatically switch between summer and winter modes based on the month. Suggested default: Enabled - optimizes for hot water in summer (May-Sep) and heating in winter (Oct-Apr). This provides the best year-round performance without manual intervention.</p>
      </div>
      <div class="homey-form-group" id="summer_mode_container">
        <label class="homey-form-checkbox">
          <input type="checkbox" id="summer_mode" />
          <span>Summer Mode</span>
        </label>
        <p class="homey-form-helper">When enabled, prioritizes hot water heating over space heating. Only used when Auto Seasonal Mode is disabled. Suggested setting: Enabled during summer months when you primarily use the heat pump for hot water rather than heating.</p>
      </div>
    </details>

    <details class="homey-form-fieldset">
      <summary class="homey-form-legend">Advanced</summary>
      <div class="homey-form-group">
        <label class="homey-form-label" for="log_level">Log Level</label>
        <select class="homey-form-input" id="log_level">
          <option value="0">Debug (Verbose)</option>
          <option value="1" selected>Info (Normal)</option>
          <option value="2">Warning (Minimal)</option>
          <option value="3">Error (Only Errors)</option>
        </select>
        <p class="homey-form-helper">Controls the amount of information logged. Debug provides the most detailed logs.</p>
      </div>
    </details>

    <details class="homey-form-fieldset">
      <summary class="homey-form-legend">Tools: Manual Triggers</summary>
      <div class="homey-form-group">
        <p class="homey-form-helper">Use these buttons to manually trigger operations.</p>
        <div class="button-container">
          <button id="run_hourly" class="homey-button-primary" onclick="runHourlyOptimization()">Run Hourly Optimization</button>
          <button id="run_weekly" class="homey-button-primary" onclick="runWeeklyCalibration()">Run Weekly Calibration</button>
          <button id="manage_cron" class="homey-button" onclick="manageScheduledJobs()">Manage Scheduled Jobs</button>
          <button id="view_thermal_data" class="homey-button" onclick="viewThermalModelData()">View Thermal Model Data</button>
        </div>
        <p id="trigger_result" class="result-message"></p>
      </div>
    </details>

    <button id="save" class="homey-button-primary-full">Save changes</button>
    <p id="save_status" class="result-message" aria-live="polite"></p>

    <script type="text/javascript">
      // Global Homey object
      let HomeyInstance;

      function normalizeDeviceListResponse(result) {
        const payload = (result && typeof result === 'object') ?
          (('devices' in result || 'buildings' in result || 'deviceList' in result)
            ? result
            : (result.result && typeof result.result === 'object'
              ? result.result
              : result))
          : {};

        const devices = Array.isArray(payload.devices)
          ? payload.devices
          : Array.isArray(payload.deviceList)
            ? payload.deviceList
            : [];
        const buildings = Array.isArray(payload.buildings)
          ? payload.buildings
          : Array.isArray(payload.buildingList)
            ? payload.buildingList
            : [];

        const success = payload.success !== false;
        const message = typeof payload.message === 'string'
          ? payload.message
          : typeof payload.error === 'string'
            ? payload.error
            : '';

        return { success, message, devices, buildings };
      }

      // Function to run hourly optimization
      function runHourlyOptimization() {
        console.log('Hourly optimization button clicked');

        // Disable button and show loading state
        document.getElementById('run_hourly').disabled = true;
        document.getElementById('trigger_result').textContent = "Running hourly optimization...";

        // Call the API
        HomeyInstance.api('GET', '/runHourlyOptimizer', {}, function(err, result) {
          const runHourlyButton = document.getElementById('run_hourly');
          const triggerResult = document.getElementById('trigger_result');

          runHourlyButton.disabled = false;

          if (err) {
            console.error('Error calling /runHourlyOptimizer:', err);
            triggerResult.textContent = "Error: " + err.message;
            HomeyInstance.alert(err.message);
            return;
          }

          console.log('/runHourlyOptimizer called successfully:', result);

          if (!result || result.success === false) {
            const message = (result && (result.message || result.error)) || 'Optimizer reported failure.';
            triggerResult.textContent = "Error: " + message;
            if (message) {
              HomeyInstance.alert(message);
            }
            return;
          }

          // Show success message
          triggerResult.textContent = "Hourly optimization completed successfully! Check the timeline for details.";
        });
      }

      // Function to run weekly calibration
      function runWeeklyCalibration() {
        console.log('Weekly calibration button clicked');

        // Disable button and show loading state
        document.getElementById('run_weekly').disabled = true;
        document.getElementById('trigger_result').textContent = "Running weekly calibration...";

        // Call the API
        HomeyInstance.api('GET', '/runWeeklyCalibration', {}, function(err, result) {
          const weeklyButton = document.getElementById('run_weekly');
          const triggerResult = document.getElementById('trigger_result');

          weeklyButton.disabled = false;

          if (err) {
            console.error('Error calling /runWeeklyCalibration:', err);
            triggerResult.textContent = "Error: " + err.message;
            HomeyInstance.alert(err.message);
            return;
          }

          console.log('/runWeeklyCalibration called successfully:', result);

          if (!result || result.success === false) {
            const message = (result && (result.message || result.error)) || 'Weekly calibration reported failure.';
            triggerResult.textContent = "Error: " + message;
            if (message) {
              HomeyInstance.alert(message);
            }
            return;
          }

          triggerResult.textContent = result.message || "Weekly calibration completed successfully!";
        });
      }

      // Function to view thermal model data
      function viewThermalModelData() {
        console.log('View thermal model data button clicked');

        // Disable button and show loading state
        document.getElementById('view_thermal_data').disabled = true;
        document.getElementById('trigger_result').textContent = "Fetching thermal model data...";

        // Call the API
        HomeyInstance.api('GET', '/getThermalModelData', {}, function(err, result) {
          if (err) {
            console.error('Error fetching thermal model data:', err);
            document.getElementById('view_thermal_data').disabled = false;
            document.getElementById('trigger_result').textContent = "Error: " + err.message;
            return HomeyInstance.alert(err.message);
          }

          console.log('Thermal model data fetched successfully:', result);

          if (result.success && result.data) {
            const data = result.data;

            // Format the data for display
            let message = `Thermal Model Data:\n\n`;
            message += `Optimization Count: ${data.optimizationCount} data points\n`;
            message += `Current K-Factor: ${data.kFactor !== null ? data.kFactor.toFixed(2) : 'Not set'}\n\n`;

            if (data.lastCalibration) {
              const calibDate = new Date(data.lastCalibration.timestamp).toLocaleString();
              message += `Last Calibration: ${calibDate}\n`;
              message += `K-Factor Change: ${data.lastCalibration.oldK.toFixed(2)} ‚Üí ${data.lastCalibration.newK.toFixed(2)}\n`;
              message += `Analysis: ${data.lastCalibration.analysis}\n\n`;
            } else {
              message += `Last Calibration: Never performed\n\n`;
            }

            if (data.lastOptimization) {
              const optDate = new Date(data.lastOptimization.timestamp).toLocaleString();
              message += `Last Optimization: ${optDate}\n`;
              message += `Target Temperature: ${data.lastOptimization.targetTemp !== undefined ? data.lastOptimization.targetTemp : 'N/A'}¬∞C (was ${data.lastOptimization.targetOriginal !== undefined ? data.lastOptimization.targetOriginal : 'N/A'}¬∞C)\n`;
              message += `Indoor Temperature: ${data.lastOptimization.indoorTemp !== undefined ? data.lastOptimization.indoorTemp : 'N/A'}¬∞C\n`;
              message += `Outdoor Temperature: ${data.lastOptimization.outdoorTemp !== undefined ? data.lastOptimization.outdoorTemp : 'N/A'}¬∞C\n`;
              message += `Current Price: ${data.lastOptimization.priceNow !== undefined ? data.lastOptimization.priceNow.toFixed(4) : 'N/A'}\n`;
            }

            // Show the data in an alert
            HomeyInstance.alert(message);
          } else {
            HomeyInstance.alert('No thermal model data available yet. Run hourly optimization to collect data.');
          }

          // Enable the button and update the result text
          document.getElementById('view_thermal_data').disabled = false;
          document.getElementById('trigger_result').textContent = "Thermal model data retrieved successfully!";
        });
      }

      // Function to manage scheduled jobs
      function manageScheduledJobs() {
        console.log('Manage scheduled jobs button clicked');

        // Disable button and show loading state
        document.getElementById('manage_cron').disabled = true;
        document.getElementById('trigger_result').textContent = "Checking scheduled jobs status...";

        // First check the current status
        HomeyInstance.api('GET', '/getCheckCronStatus', {}, function(err, result) {
          if (err) {
            console.error('Error checking cron status:', err);
            document.getElementById('manage_cron').disabled = false;
            document.getElementById('trigger_result').textContent = "Error: " + err.message;
            return HomeyInstance.alert(err.message);
          }

          console.log('Cron status check successful:', result);

          // Format the result for display
          const hourlyStatus = result.hourlyJob.running ? 'Running' : 'Not running';
          const weeklyStatus = result.weeklyJob.running ? 'Running' : 'Not running';
          const hourlyNextRun = new Date(result.hourlyJob.nextRun).toLocaleString();
          const weeklyNextRun = new Date(result.weeklyJob.nextRun).toLocaleString();
          const lastHourlyRun = result.lastHourlyRun ? new Date(result.lastHourlyRun).toLocaleString() : 'Never';
          const lastWeeklyRun = result.lastWeeklyRun ? new Date(result.lastWeeklyRun).toLocaleString() : 'Never';

          // Create a formatted message
          const statusMessage = `
            Current time: ${new Date(result.currentTime).toLocaleString()}

            Hourly job: ${hourlyStatus}
            Next run: ${hourlyNextRun}
            Last run: ${lastHourlyRun}

            Weekly job: ${weeklyStatus}
            Next run: ${weeklyNextRun}
            Last run: ${lastWeeklyRun}
          `;

          // Ask the user what they want to do
          if (confirm(statusMessage + '\n\nDo you want to restart the scheduled jobs?')) {
            // User clicked OK, start/restart the jobs
            document.getElementById('trigger_result').textContent = "Starting scheduled jobs...";

            // Call the API to start cron jobs
            HomeyInstance.api('GET', '/getStartCronJobs', {}, function(startErr, startResult) {
              if (startErr) {
                console.error('Error starting cron jobs:', startErr);
                document.getElementById('manage_cron').disabled = false;
                document.getElementById('trigger_result').textContent = "Error: " + startErr.message;
                return HomeyInstance.alert(startErr.message);
              }

              console.log('Cron jobs started successfully:', startResult);

              // Create a formatted message
              const startMessage = `
                Scheduled jobs started successfully!

                Hourly job running: ${startResult.hourlyJobRunning ? 'Yes' : 'No'}
                Weekly job running: ${startResult.weeklyJobRunning ? 'Yes' : 'No'}
              `;

              // Show the status in an alert
              HomeyInstance.alert(startMessage);

              // Enable the button and update the result text
              document.getElementById('manage_cron').disabled = false;
              document.getElementById('trigger_result').textContent = "Scheduled jobs started successfully!";
            });
          } else {
            // User clicked Cancel, just enable the button
            document.getElementById('manage_cron').disabled = false;
            document.getElementById('trigger_result').textContent = "Scheduled jobs status checked successfully!";
          }
        });
      }

      function onHomeyReady(Homey) {
        console.log('onHomeyReady called - Settings page initialized');

        // Store Homey instance globally
        HomeyInstance = Homey;

        // Tell Homey we're ready to be displayed
        Homey.ready();
        console.log('Homey.ready() called');

        // Helper function to check if a value should override HTML defaults
        function hasValidValue(err, value) {
          return !err && value !== undefined && value !== null && value !== "";
        }

        // Get elements
        const melcloudUserElement = document.getElementById("melcloud_user");
        const melcloudPassElement = document.getElementById("melcloud_pass");
        const deviceIdElement = document.getElementById("device_id");
        const buildingIdElement = document.getElementById("building_id");
        const refreshDevicesButton = document.getElementById("refresh_devices");
        const deviceRefreshStatus = document.getElementById("device_refresh_status");
        const showManualEntryElement = document.getElementById("show_manual_entry");
        const manualIdEntryDiv = document.getElementById("manual_id_entry");
        const manualDeviceIdElement = document.getElementById("manual_device_id");
        const manualBuildingIdElement = document.getElementById("manual_building_id");
        const tibberTokenElement = document.getElementById("tibber_token");
        const priceSourceTibberElement = document.getElementById("price_source_tibber");
        const priceSourceEntsoeElement = document.getElementById("price_source_entsoe");
        const priceSourceStatusElement = document.getElementById("price_source_status");
        const tibberTokenGroup = tibberTokenElement ? tibberTokenElement.closest('.homey-form-group') : null;
        const entsoeQuickDetails = document.getElementById("entsoe_quick_settings");
        const entsoeZoneInput = document.getElementById("entsoe_zone_input");
        const entsoeAutoButton = document.getElementById("entsoe_auto_detect");
        const entsoeOpenFullButton = document.getElementById("entsoe_open_full");
        const entsoeFullContainer = document.getElementById("entsoe_full_container");
        const entsoeFullFrame = document.getElementById("entsoe_full_frame");
        const entsoeZoneStatus = document.getElementById("entsoe_zone_status");
        const tempStepMaxElement = document.getElementById("temp_step_max");
        const useWeatherDataElement = document.getElementById("use_weather_data");
        const latitudeElement = document.getElementById("latitude");
        const longitudeElement = document.getElementById("longitude");
        const detectLocationButton = document.getElementById("detect-location");
        const dayStartHourElement = document.getElementById("day_start_hour");
        const dayEndHourElement = document.getElementById("day_end_hour");
        const nightTempReductionElement = document.getElementById("night_temp_reduction");
        const preHeatHoursElement = document.getElementById("pre_heat_hours");
        const timeZoneOffsetElement = document.getElementById("time_zone_offset");
        const useDstElement = document.getElementById("use_dst");
        const timeZoneNameElement = document.getElementById("time_zone_name");
        const timeZoneNameListElement = document.getElementById("time_zone_name_list");
        const detectTimeZoneNameButton = document.getElementById("detect_time_zone_name");
        const timeZoneNameStatusElement = document.getElementById("time_zone_name_status");
        const logLevelElement = document.getElementById("log_level");
        const notifyOnSuccessElement = document.getElementById("notify_on_success");
        const timelineVerbosityElement = document.getElementById("timeline_verbosity");
        const currencyCodeElement = document.getElementById("currency_code");
        const saveElement = document.getElementById("save");

        // Enhanced timezone list population with common zones prioritized
        if (timeZoneNameListElement) {
          try {
            // Common zones that users are likely to need (prioritized)
            const commonZones = [
              'Europe/Stockholm', 'Europe/Oslo', 'Europe/Copenhagen', 'Europe/Helsinki',
              'Europe/Berlin', 'Europe/Paris', 'Europe/Amsterdam', 'Europe/Brussels',
              'Europe/London', 'Europe/Dublin', 'Europe/Rome', 'Europe/Madrid',
              'Europe/Warsaw', 'Europe/Prague', 'Europe/Vienna', 'Europe/Zurich',
              'America/New_York', 'America/Chicago', 'America/Denver', 'America/Los_Angeles',
              'America/Toronto', 'America/Vancouver', 'America/Sao_Paulo', 'America/Mexico_City',
              'Asia/Tokyo', 'Asia/Shanghai', 'Asia/Hong_Kong', 'Asia/Singapore',
              'Asia/Dubai', 'Asia/Kolkata', 'Asia/Bangkok', 'Asia/Jakarta',
              'Australia/Sydney', 'Australia/Melbourne', 'Australia/Perth',
              'Pacific/Auckland', 'Africa/Johannesburg'
            ];

            if (typeof Intl !== 'undefined' && typeof Intl.supportedValuesOf === 'function') {
              const allTzValues = Intl.supportedValuesOf('timeZone');
              
              // Add common zones first
              commonZones.forEach(tz => {
                if (allTzValues.includes(tz)) {
                  const option = document.createElement('option');
                  option.value = tz;
                  timeZoneNameListElement.appendChild(option);
                }
              });
              
              // Add remaining zones
              allTzValues.forEach(tz => {
                if (!commonZones.includes(tz)) {
                  const option = document.createElement('option');
                  option.value = tz;
                  timeZoneNameListElement.appendChild(option);
                }
              });
            } else {
              // Fallback to common zones only
              commonZones.forEach(tz => {
                const option = document.createElement('option');
                option.value = tz;
                timeZoneNameListElement.appendChild(option);
              });
            }
          } catch (error) {
            console.warn('Failed to populate timezone list', error);
          }
        }

        // Enhanced timezone detection with preview
        const timezonePreviewElement = document.getElementById("timezone_preview");
        const timezonePreviewTimeElement = document.getElementById("timezone_preview_time");
        const migrationNoticeElement = document.getElementById("migration_notice");
        const convertToAutoButton = document.getElementById("convert_to_auto");

        function updateTimezonePreview(timezone) {
          if (!timezone || !timezonePreviewElement || !timezonePreviewTimeElement) return;
          
          try {
            const now = new Date();
            const formatter = new Intl.DateTimeFormat('en-US', {
              timeZone: timezone,
              weekday: 'short',
              year: 'numeric',
              month: 'short', 
              day: 'numeric',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit',
              timeZoneName: 'short'
            });
            
            timezonePreviewTimeElement.textContent = formatter.format(now);
            timezonePreviewElement.style.display = 'block';
          } catch (error) {
            console.warn('Failed to format timezone preview:', error);
            timezonePreviewElement.style.display = 'none';
          }
        }

        function validateTimezone(timezone) {
          if (!timezone) return false;
          try {
            Intl.DateTimeFormat(undefined, { timeZone: timezone });
            return true;
          } catch (error) {
            return false;
          }
        }

        if (detectTimeZoneNameButton && timeZoneNameElement) {
          detectTimeZoneNameButton.addEventListener('click', () => {
            try {
              const resolved = Intl.DateTimeFormat().resolvedOptions().timeZone;
              if (resolved) {
                timeZoneNameElement.value = resolved;
                updateTimezonePreview(resolved);
                if (timeZoneNameStatusElement) {
                  timeZoneNameStatusElement.textContent = `‚úÖ Auto-detected: ${resolved}`;
                  timeZoneNameStatusElement.style.color = '#00aa44';
                }
                // Trigger save
                save('time_zone_name', resolved);
              }
            } catch (error) {
              console.warn('Failed to detect device timezone', error);
              if (timeZoneNameStatusElement) {
                timeZoneNameStatusElement.textContent = '‚ùå Could not auto-detect timezone';
                timeZoneNameStatusElement.style.color = '#cc0000';
              }
            }
          });
        }

        if (timeZoneNameElement && timeZoneNameStatusElement) {
          timeZoneNameElement.addEventListener('input', () => {
            const value = (timeZoneNameElement.value || '').trim();
            
            if (!value) {
              timeZoneNameStatusElement.textContent = 'Will use manual UTC offset if configured';
              timeZoneNameStatusElement.style.color = '#888';
              timezonePreviewElement.style.display = 'none';
              return;
            }

            if (validateTimezone(value)) {
              timeZoneNameStatusElement.textContent = `‚úÖ Valid timezone: ${value}`;
              timeZoneNameStatusElement.style.color = '#00aa44';
              updateTimezonePreview(value);
            } else {
              timeZoneNameStatusElement.textContent = `‚ùå Invalid timezone: ${value}`;
              timeZoneNameStatusElement.style.color = '#cc0000';
              timezonePreviewElement.style.display = 'none';
            }
          });

          // Trigger validation on initial load
          const initialValue = timeZoneNameElement.value;
          if (initialValue) {
            timeZoneNameElement.dispatchEvent(new Event('input'));
          }
        }

        // Check for migration opportunity and show notice
        function checkMigrationOpportunity() {
          const currentTimezone = load('time_zone_name');
          const currentOffset = load('time_zone_offset');
          
          if (!currentTimezone && currentOffset !== null) {
            // User has manual settings but no IANA timezone
            if (migrationNoticeElement) {
              migrationNoticeElement.style.display = 'block';
            }
          }
        }

        if (convertToAutoButton) {
          convertToAutoButton.addEventListener('click', () => {
            try {
              const resolved = Intl.DateTimeFormat().resolvedOptions().timeZone;
              if (resolved && timeZoneNameElement) {
                timeZoneNameElement.value = resolved;
                timeZoneNameElement.dispatchEvent(new Event('input'));
                save('time_zone_name', resolved);
                
                if (migrationNoticeElement) {
                  migrationNoticeElement.innerHTML = `
                    <p style="margin: 0; color: #00aa44;">
                      ‚úÖ <strong>Converted Successfully:</strong> Now using automatic timezone: ${resolved}
                    </p>
                  `;
                  setTimeout(() => {
                    migrationNoticeElement.style.display = 'none';
                  }, 5000);
                }
              }
            } catch (error) {
              console.warn('Failed to convert to automatic timezone', error);
            }
          });
        }

        // Check migration opportunity on page load
        setTimeout(checkMigrationOpportunity, 500);

        // ===== Model Confidence Section =====
        const refreshModelConfidenceButton = document.getElementById('refresh_model_confidence');
        const modelConfidenceLoading = document.getElementById('model_confidence_loading');
        const modelConfidenceContent = document.getElementById('model_confidence_content');
        const modelConfidenceValue = document.getElementById('model_confidence_value');
        const modelConfidenceStatus = document.getElementById('model_confidence_status');
        const heatingRateRow = document.getElementById('heating_rate_row');
        const heatingRateValue = document.getElementById('heating_rate_value');
        const coolingRateRow = document.getElementById('cooling_rate_row');
        const coolingRateValue = document.getElementById('cooling_rate_value');
        const thermalMassRow = document.getElementById('thermal_mass_row');
        const thermalMassValue = document.getElementById('thermal_mass_value');
        const modelThermalDetails = document.getElementById('model_thermal_details');
        const lastCalibrationRow = document.getElementById('last_calibration_row');
        const lastCalibrationValue = document.getElementById('last_calibration_value');
        const learningCyclesRow = document.getElementById('learning_cycles_row');
        const learningCyclesValue = document.getElementById('learning_cycles_value');
        const modelLearningDetails = document.getElementById('model_learning_details');
        const thermalRawPoints = document.getElementById('thermal_raw_points');
        const thermalAggPoints = document.getElementById('thermal_agg_points');
        const thermalTotalKb = document.getElementById('thermal_total_kb');
        const modelRetentionDetails = document.getElementById('model_retention_details');
        const modelEmptyState = document.getElementById('model_empty_state');
        const modelErrorState = document.getElementById('model_error_state');
        const modelErrorMessage = document.getElementById('model_error_message');

        function getConfidenceStatus(pct) {
          if (pct === null || pct === undefined) return 'Learning';
          if (pct < 25) return 'Learning';
          if (pct < 60) return 'Improving';
          if (pct < 85) return 'Reliable';
          return 'Highly reliable';
        }

        // Helper functions for System Learning Overview
        function toPct(n) {
          if (n == null || isNaN(n)) return null;
          const pct = Math.round(Math.max(0, Math.min(1, n)) * 100);
          return pct; // 0..100
        }

        function statusFrom(pct) {
          if (pct == null) return "Learning";
          if (pct < 25) return "Learning";
          if (pct < 60) return "Improving";
          if (pct < 85) return "Reliable";
          return "Highly reliable";
        }

        // Heuristic for price if only a weight (0..1) exists:
        function priceStatusFromAdaptive(adaptive) {
          // Prefer explicit confidence if available
          if (adaptive && typeof adaptive.confidence === 'number') {
            return statusFrom(toPct(adaptive.confidence));
          }
          // Fallback: use learningCycles as a rough proxy for maturity
          if (adaptive && typeof adaptive.learningCycles === 'number') {
            // Map learning cycles to a confidence-like score (rough heuristic)
            // 0-10 cycles ‚Üí 0-0.25, 10-50 cycles ‚Üí 0.25-0.6, 50-100 cycles ‚Üí 0.6-0.85, 100+ ‚Üí 0.85-1.0
            const cycles = adaptive.learningCycles;
            let approxConfidence;
            if (cycles < 10) {
              approxConfidence = cycles / 40; // 0-0.25
            } else if (cycles < 50) {
              approxConfidence = 0.25 + ((cycles - 10) / 100); // 0.25-0.6
            } else if (cycles < 100) {
              approxConfidence = 0.6 + ((cycles - 50) / 200); // 0.6-0.85
            } else {
              approxConfidence = 0.85 + (Math.min(cycles - 100, 100) / 667); // 0.85-1.0
            }
            return statusFrom(toPct(approxConfidence));
          }
          return "Learning";
        }

        // Hot water patterns confidence (0..1 or 0..100) if available
        function hotWaterStatusFromPatterns(patterns) {
          if (patterns && typeof patterns.confidence === 'number') {
            // Hot water confidence is stored as 0-100, not 0-1
            const pct = patterns.confidence > 1 ? patterns.confidence : toPct(patterns.confidence);
            return statusFrom(pct);
          }
          return "Learning";
        }

        // Helper functions for Smart Savings display
        function fmtMoney(n, currencySymbol, decimals = 2) {
          if (n == null || isNaN(n)) return "‚Äî";
          const precision = typeof decimals === 'number' && decimals >= 0 ? decimals : 2;
          const symbol = (currencySymbol || "").trim();
          const formatter = new Intl.NumberFormat(undefined, {
            minimumFractionDigits: 0,
            maximumFractionDigits: precision
          });
          const formatted = formatter.format(Number(n));
          return symbol ? `${formatted} ${symbol}` : formatted;
        }

        function ss_select(elOn, elOff) {
          if (elOn) elOn.setAttribute('aria-pressed', 'true');
          if (elOff) elOff.setAttribute('aria-pressed', 'false');
        }

        function ss_subset(history, days) {
          if (!Array.isArray(history) || history.length === 0) return [];
          const n = Math.min(days, history.length);
          return history.slice(-n);
        }

        function ss_drawChart(svg, points, currency) {
          while (svg.firstChild) svg.removeChild(svg.firstChild);

          const W = 320, H = 80, P = 6;
          svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
          if (!points || points.length === 0) return;

          const xs = points.map((_, i) => i);
          const ys = points.map(p => (typeof p.valueMajor === 'number' ? p.valueMajor : 0));

          const minX = 0;
          const derivedMaxX = xs.length - 1;
          const maxX = derivedMaxX >= 0 ? (derivedMaxX || 1) : 1;
          const minY = Math.min(...ys, 0);
          const maxY = Math.max(...ys, 1);
          const denomX = maxX - minX || 1;
          const denomY = maxY - minY || 1;

          const xScale = x => P + (W - 2 * P) * (x - minX) / denomX;
          const yScale = y => H - P - (H - 2 * P) * (y - minY) / denomY;

          const grid = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          grid.setAttribute('d', `M ${P} ${yScale(0)} L ${W - P} ${yScale(0)}`);
          grid.setAttribute('stroke', '#ddd');
          grid.setAttribute('stroke-width', '1');
          svg.appendChild(grid);

          let d = '';
          xs.forEach((x, i) => {
            const X = xScale(x);
            const Y = yScale(ys[i]);
            d += (i === 0 ? `M ${X} ${Y}` : ` L ${X} ${Y}`);
          });
          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('d', d);
          path.setAttribute('fill', 'none');
          path.setAttribute('stroke', '#555');
          path.setAttribute('stroke-width', '2');
          svg.appendChild(path);

          const area = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          const areaD = `${d} L ${xScale(maxX)} ${H - P} L ${xScale(minX)} ${H - P} Z`;
          area.setAttribute('d', areaD);
          area.setAttribute('fill', '#000');
          area.setAttribute('opacity', '0.06');
          svg.appendChild(area);

          const lastX = xScale(maxX);
          const lastY = yScale(ys[ys.length - 1]);
          const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          dot.setAttribute('cx', lastX);
          dot.setAttribute('cy', lastY);
          dot.setAttribute('r', '2.8');
          dot.setAttribute('fill', '#000');
          svg.appendChild(dot);

          const last = ys[ys.length - 1];
          svg.setAttribute('aria-label', `Savings over time. Last value ${last.toFixed(2)} ${currency || ''}`);
        }

        function renderSystemLearningOverview(snapshot) {
          // DOM targets
          const elTemp  = document.querySelector('#slo-temp .value');
          const elTempDetail = document.querySelector('#slo-temp .detail');
          const elPrice = document.querySelector('#slo-price .value');
          const elPriceDetail = document.querySelector('#slo-price .detail');
          const elHW    = document.querySelector('#slo-hw .value');
          const elHWDetail = document.querySelector('#slo-hw .detail');

          // 1) Temperature model from thermalModel.confidence
          let tempStatus = "Learning";
          let tempDetail = "Collecting data...";
          if (snapshot && snapshot.thermalModel && typeof snapshot.thermalModel.confidence === 'number') {
            tempStatus = statusFrom(toPct(snapshot.thermalModel.confidence));
          }
          if (snapshot && snapshot.dataRetention) {
            const totalPoints = (snapshot.dataRetention.thermalRawPoints || 0) + (snapshot.dataRetention.thermalAggPoints || 0);
            const lastUpdated = snapshot.thermalModel?.lastUpdated;
            
            if (totalPoints > 0) {
              // Have data points
              const pointsText = `${totalPoints} data points`;
              const updatedText = lastUpdated 
                ? new Date(lastUpdated).toLocaleDateString(undefined, { month: 'short', day: 'numeric' })
                : 'Recently';
              tempDetail = `${pointsText} ‚Ä¢ Last updated: ${updatedText}`;
            } else if (lastUpdated) {
              // No data points but have a last updated timestamp
              const updatedText = new Date(lastUpdated).toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
              tempDetail = `No samples yet ‚Ä¢ Model last run: ${updatedText}`;
            }
          }
          if (elTemp) elTemp.textContent = tempStatus;
          if (elTempDetail) elTempDetail.textContent = tempDetail;

          // 2) Price strategy from adaptiveParameters
          let priceStatus = "Learning";
          let priceDetail = "No optimization runs yet";
          if (snapshot && snapshot.adaptiveParameters) {
            priceStatus = priceStatusFromAdaptive(snapshot.adaptiveParameters);
            const cycles = snapshot.adaptiveParameters.learningCycles || 0;
            const cyclesText = cycles > 0 ? `${cycles} learning cycles` : 'No cycles';
            
            // Add average savings if available
            let savingsText = '';
            if (snapshot.savingsMetrics && snapshot.savingsMetrics.averageDailySavings !== null) {
              const avgSavings = snapshot.savingsMetrics.averageDailySavings;
              const savingsPercent = avgSavings > 0 ? Math.round(avgSavings * 100) / 100 : 0;
              savingsText = ` ‚Ä¢ Avg savings: ${savingsPercent.toFixed(1)}%`;
            }
            
            priceDetail = `${cyclesText}${savingsText}`;
          }
          if (elPrice) elPrice.textContent = priceStatus;
          if (elPriceDetail) elPriceDetail.textContent = priceDetail;

          // 3) Hot water forecast from snapshot
          let hwStatus = "Learning";
          let hwDetail = "Collecting usage data";
          if (snapshot && snapshot.hotWaterPatterns) {
            hwStatus = hotWaterStatusFromPatterns(snapshot.hotWaterPatterns);
            const confidence = snapshot.hotWaterPatterns.confidence;
            const confidenceText = confidence !== null ? `${Math.round(confidence)}% confidence` : 'No confidence';
            
            // Identify peak hours from hourly pattern
            let peakHoursText = '';
            if (snapshot.hotWaterPatterns.hourlyUsagePattern && Array.isArray(snapshot.hotWaterPatterns.hourlyUsagePattern)) {
              const pattern = snapshot.hotWaterPatterns.hourlyUsagePattern;
              const avgUsage = pattern.reduce((sum, val) => sum + val, 0) / pattern.length;
              const peakHours = pattern
                .map((usage, hour) => ({ hour, usage }))
                .filter(h => h.usage > avgUsage * 1.3) // 30% above average
                .sort((a, b) => b.usage - a.usage)
                .slice(0, 4) // Top 4 peak hours
                .map(h => h.hour)
                .sort((a, b) => a - b);
              
              if (peakHours.length > 0) {
                // Group consecutive hours
                const ranges = [];
                let start = peakHours[0];
                let end = peakHours[0];
                for (let i = 1; i <= peakHours.length; i++) {
                  if (i < peakHours.length && peakHours[i] === end + 1) {
                    end = peakHours[i];
                  } else {
                    ranges.push(start === end ? `${start}` : `${start}-${end}`);
                    if (i < peakHours.length) {
                      start = peakHours[i];
                      end = peakHours[i];
                    }
                  }
                }
                peakHoursText = ` ‚Ä¢ Peak hours: ${ranges.join(', ')}`;
              }
            }
            
            hwDetail = `${confidenceText}${peakHoursText}`;
          }
          if (elHW) elHW.textContent = hwStatus;
          if (elHWDetail) elHWDetail.textContent = hwDetail;
        }

        function renderSmartSavingsDisplay(snapshot) {
          const elToday = document.getElementById('smart-savings-today');
          const el7d = document.getElementById('smart-savings-7d');
          const elProj = document.getElementById('smart-savings-projection');
          const elSeason = document.getElementById('smart-savings-season');
          const elNote = document.getElementById('smart-savings-note');
          const svg = document.getElementById('smart-savings-chart');
          const empty = document.getElementById('smart-savings-chart-empty');
          const btn7 = document.getElementById('ss-range-7');
          const btn30 = document.getElementById('ss-range-30');

          const smart = snapshot?.smartSavingsDisplay || {};
          const todayMajor = smart.todayMajor ?? smart.today ?? null;
          const last7Major = smart.last7Major ?? smart.last7 ?? null;
          const projectionMajor = smart.monthlyProjectionMajor ?? smart.projection ?? null;
          const mode = smart.seasonMode || snapshot?.seasonalMode || null;
          const currencySymbol = smart.currencySymbol || smart.currency || snapshot?.priceData?.currencySymbol || snapshot?.priceData?.currency || 'SEK';
          const decimals = typeof smart.decimals === 'number' ? smart.decimals : 2;

          if (elToday) {
            elToday.textContent = todayMajor !== null
              ? `${fmtMoney(todayMajor, currencySymbol, decimals)} saved`
              : '‚Äî';
          }

          if (el7d) {
            el7d.textContent = last7Major !== null
              ? `${fmtMoney(last7Major, currencySymbol, decimals)} saved`
              : '‚Äî';
          }

          if (elProj) {
            elProj.textContent = projectionMajor !== null
              ? `~${fmtMoney(projectionMajor, currencySymbol, decimals)}/month`
              : '‚Äî';
          }

          if (elSeason) {
            if (mode) {
              const labels = {
                winter: 'Winter',
                transition: 'Transitional',
                transitional: 'Transitional',
                summer: 'Summer'
              };
              elSeason.textContent = labels[mode] || mode;
            } else {
              elSeason.textContent = '‚Äî';
            }
          }

          const historyRaw = Array.isArray(smart.history)
            ? smart.history.slice().sort((a, b) => (a.date < b.date ? -1 : a.date > b.date ? 1 : 0))
            : [];

          if (svg && empty) {
            function updateChart(days) {
              const subset = ss_subset(historyRaw, days);
              if (!subset.length) {
                svg.style.display = 'none';
                empty.style.display = 'block';
              } else {
                svg.style.display = 'block';
                empty.style.display = 'none';
                ss_drawChart(svg, subset, smart.currency || currencySymbol);
              }
            }

            updateChart(7);
            ss_select(btn7, btn30);

            if (btn7) {
              btn7.onclick = () => {
                updateChart(7);
                ss_select(btn7, btn30);
              };
            }
            if (btn30) {
              btn30.onclick = () => {
                updateChart(30);
                ss_select(btn30, btn7);
              };
            }
          }

          if (elNote) {
            if (!historyRaw.length && todayMajor === null && last7Major === null) {
              elNote.textContent = 'Optimizer is learning your baseline; savings will appear after a few hourly runs.';
            } else if (!historyRaw.length) {
              elNote.textContent = 'No savings history yet.';
            } else if (projectionMajor === null) {
              elNote.textContent = 'Monthly projection appears once a few days of smart savings history are collected.';
            } else {
              elNote.textContent = 'Estimates compare the optimizer to traditional constant-temperature heating using seasonal COP adjustments.';
            }
          }
        }

        function fetchModelConfidence() {
          if (!Homey || !Homey.api) {
            console.error('Homey API not available');
            return;
          }

          // Show loading state
          if (refreshModelConfidenceButton) {
            refreshModelConfidenceButton.disabled = true;
            refreshModelConfidenceButton.textContent = 'Loading‚Ä¶';
          }
          if (modelConfidenceLoading) {
            modelConfidenceLoading.style.display = 'block';
          }
          if (modelConfidenceContent) {
            modelConfidenceContent.style.opacity = '0.5';
          }

          Homey.api('GET', '/getModelConfidence', {}, function(err, result) {
            // Re-enable button
            if (refreshModelConfidenceButton) {
              refreshModelConfidenceButton.disabled = false;
              refreshModelConfidenceButton.textContent = 'Refresh';
            }
            if (modelConfidenceLoading) {
              modelConfidenceLoading.style.display = 'none';
            }
            if (modelConfidenceContent) {
              modelConfidenceContent.style.opacity = '1';
            }

            if (err || !result || !result.success) {
              console.error('Error fetching model confidence:', err || result);
              if (modelErrorState && modelErrorMessage) {
                modelErrorState.style.display = 'block';
                modelErrorMessage.textContent = err ? err.message : (result?.error || 'Failed to load model confidence');
              }
              if (modelEmptyState) {
                modelEmptyState.style.display = 'none';
              }
              return;
            }

            // Hide error state
            if (modelErrorState) {
              modelErrorState.style.display = 'none';
            }

            const data = result;
            const thermalModel = data.thermalModel || {};
            const adaptiveParams = data.adaptiveParameters || {};
            const dataRetention = data.dataRetention || {};

            // Update confidence display
            const confidencePct = thermalModel.confidence !== null && thermalModel.confidence !== undefined
              ? Math.round(thermalModel.confidence * 100)
              : null;
            const status = getConfidenceStatus(confidencePct);

            if (modelConfidenceValue) {
              modelConfidenceValue.textContent = confidencePct !== null ? confidencePct + '%' : '‚Äî';
            }
            if (modelConfidenceStatus) {
              modelConfidenceStatus.textContent = status;
            }

            // Show/hide empty state
            const hasData = confidencePct !== null || thermalModel.heatingRate !== null || 
                           adaptiveParams.learningCycles !== null;
            if (modelEmptyState) {
              modelEmptyState.style.display = hasData ? 'none' : 'block';
            }

            // Update thermal details
            let thermalDetailsVisible = false;
            if (thermalModel.heatingRate !== null && thermalModel.heatingRate !== undefined) {
              if (heatingRateRow && heatingRateValue) {
                heatingRateRow.style.display = 'block';
                heatingRateValue.textContent = thermalModel.heatingRate.toFixed(2) + ' ¬∞C/h';
                thermalDetailsVisible = true;
              }
            } else if (heatingRateRow) {
              heatingRateRow.style.display = 'none';
            }

            if (thermalModel.coolingRate !== null && thermalModel.coolingRate !== undefined) {
              if (coolingRateRow && coolingRateValue) {
                coolingRateRow.style.display = 'block';
                coolingRateValue.textContent = thermalModel.coolingRate.toFixed(2) + ' ¬∞C/h';
                thermalDetailsVisible = true;
              }
            } else if (coolingRateRow) {
              coolingRateRow.style.display = 'none';
            }

            if (thermalModel.thermalMass !== null && thermalModel.thermalMass !== undefined) {
              if (thermalMassRow && thermalMassValue) {
                thermalMassRow.style.display = 'block';
                thermalMassValue.textContent = thermalModel.thermalMass.toFixed(2);
                thermalDetailsVisible = true;
              }
            } else if (thermalMassRow) {
              thermalMassRow.style.display = 'none';
            }

            if (modelThermalDetails) {
              modelThermalDetails.style.display = thermalDetailsVisible ? 'block' : 'none';
            }

            // Update learning details
            let learningDetailsVisible = false;
            if (thermalModel.lastUpdated) {
              if (lastCalibrationRow && lastCalibrationValue) {
                lastCalibrationRow.style.display = 'block';
                try {
                  const date = new Date(thermalModel.lastUpdated);
                  lastCalibrationValue.textContent = date.toLocaleString();
                } catch (e) {
                  lastCalibrationValue.textContent = thermalModel.lastUpdated;
                }
                learningDetailsVisible = true;
              }
            } else if (lastCalibrationRow) {
              lastCalibrationRow.style.display = 'none';
            }

            if (adaptiveParams.learningCycles !== null && adaptiveParams.learningCycles !== undefined) {
              if (learningCyclesRow && learningCyclesValue) {
                learningCyclesRow.style.display = 'block';
                learningCyclesValue.textContent = adaptiveParams.learningCycles.toString();
                learningDetailsVisible = true;
              }
            } else if (learningCyclesRow) {
              learningCyclesRow.style.display = 'none';
            }

            if (modelLearningDetails) {
              modelLearningDetails.style.display = learningDetailsVisible ? 'block' : 'none';
            }

            // Update retention details
            const hasRetentionData = (dataRetention.thermalRawPoints > 0) || 
                                    (dataRetention.thermalAggPoints > 0);
            if (hasRetentionData && modelRetentionDetails) {
              modelRetentionDetails.style.display = 'block';
              if (thermalRawPoints) {
                thermalRawPoints.textContent = dataRetention.thermalRawPoints || '0';
              }
              if (thermalAggPoints) {
                thermalAggPoints.textContent = dataRetention.thermalAggPoints || '0';
              }
              if (thermalTotalKb) {
                const totalKb = (dataRetention.rawKB || 0) + (dataRetention.aggKB || 0);
                thermalTotalKb.textContent = totalKb.toFixed(2);
              }
            } else if (modelRetentionDetails) {
              modelRetentionDetails.style.display = 'none';
            }

            // Update System Learning Overview
            renderSystemLearningOverview(data);
            
            // Update Savings Overview
            renderSmartSavingsDisplay(data);
          });
        }

        // Attach refresh button handler
        if (refreshModelConfidenceButton) {
          refreshModelConfidenceButton.addEventListener('click', fetchModelConfidence);
        }

        // Fetch model confidence on page load
        setTimeout(fetchModelConfidence, 1000);
        // ===== End Model Confidence Section =====

        // Consumer markup elements (declared early to avoid initialization errors)
        const enableConsumerMarkupElement = document.getElementById("enable_consumer_markup");
        const consumerMarkupConfigElement = document.getElementById("consumer_markup_config");
        const markupCurrencyUnitElement = document.getElementById("markup_currency_unit");
        const consumerMarkupSection = document.getElementById("consumer_markup_section");
        const consumerMarkupConfigSection = document.getElementById("consumer_markup_config_section");
        const markupCurrencySection = document.getElementById("markup_currency_section");
        const loadMarkupDefaultsButton = document.getElementById("load_markup_defaults");
        const consumerMarkupStatus = document.getElementById("consumer_markup_status");

        // Zone2 elements
        const enableZone2Element = document.getElementById("enable_zone2");
        const zone2SettingsDiv = document.getElementById("zone2_settings");
        const zone2Fieldset = document.getElementById("zone2_fieldset");
        const minTempZone2Element = document.getElementById("min_temp_zone2");
        const maxTempZone2Element = document.getElementById("max_temp_zone2");
        const tempStepZone2Element = document.getElementById("temp_step_zone2");

        // COP settings elements
        const copWeightElement = document.getElementById("cop_weight");
        const autoSeasonalModeElement = document.getElementById("auto_seasonal_mode");
        const summerModeElement = document.getElementById("summer_mode");
        const summerModeContainer = document.getElementById("summer_mode_container");

        let entsoeAreaMap = null;
        let entsoeAutoSelectionDone = false;

        function updateEntsoeZoneInput(value, message) {
          if (entsoeZoneInput && typeof value === 'string') {
            entsoeZoneInput.value = value;
          }
          if (message && entsoeZoneStatus) {
            entsoeZoneStatus.textContent = message;
          } else if (entsoeZoneStatus && !message) {
            entsoeZoneStatus.textContent = '';
          }
        }

        function saveEntsoeZone(value, opts = {}) {
          const trimmed = (value || '').toString().trim();
          persistSetting('entsoe_area_eic', trimmed, {
            trimString: true,
            onSuccess: function () {
              if (!opts.silent && entsoeZoneStatus) {
                entsoeZoneStatus.textContent = trimmed
                  ? `Saved ENTSO-E zone: ${trimmed}`
                  : 'Cleared ENTSO-E zone. Enter an ISO code (SE3) or EIC.';
              }
            },
            onUnset: function () {
              if (!opts.silent && entsoeZoneStatus) {
                entsoeZoneStatus.textContent = 'Cleared ENTSO-E zone. Enter an ISO code (SE3) or EIC.';
              }
            }
          });
        }

        function persistSetting(key, rawValue, options = {}) {
          const {
            allowEmptyString = false,
            trimString = false,
            onSuccess,
            onUnset
          } = options;

          let value = rawValue;
          if (trimString && typeof value === 'string') {
            value = value.trim();
          }

          const isEmptyString = typeof value === 'string' && value.length === 0;
          const isInvalidNumber = typeof value === 'number' && Number.isNaN(value);
          const isNullish = value === undefined || value === null;

          if (!allowEmptyString && (isEmptyString || isInvalidNumber || isNullish)) {
            if (typeof Homey.unset === 'function') {
              Homey.unset(key, function (err) {
                if (err) {
                  console.error(`Failed to clear setting ${key}`, err);
                  // Don't show individual alerts for clearing settings - just log them
                } else if (typeof onUnset === 'function') {
                  onUnset();
                }
              });
            } else {
              console.warn(`Homey.unset is unavailable; attempting to clear setting ${key} using null value`);
              Homey.set(key, null, function (err) {
                if (err) {
                  console.error(`Failed to clear setting ${key} via null`, err);
                  // Don't show individual alerts for clearing settings - just log them
                } else if (typeof onUnset === 'function') {
                  onUnset();
                }
              });
            }
            return;
          }

          Homey.set(key, value, function (err) {
            if (err) {
              console.error(`Failed to store setting ${key}`, err);
              // Don't show individual alerts for each setting error - just log them
              return;
            }
            if (typeof onSuccess === 'function') {
              onSuccess();
            }
          });
        }

        function handleEntsoeZoneSelected(payload) {
          if (!payload || payload.type !== 'entsoe:zoneSelected') {
            return;
          }
          const eic = (payload.eic || '').toString().trim();
          if (!eic) {
            return;
          }
          entsoeAutoSelectionDone = true;
          const display = typeof payload.display === 'string' && payload.display.trim()
            ? payload.display.trim()
            : '';
          saveEntsoeZone(eic, { silent: true });
          const message = display
            ? `Saved ENTSO-E zone: ${display} (${eic}).`
            : `Saved ENTSO-E zone: ${eic}.`;
          updateEntsoeZoneInput(eic, message);
        }

        window.__entsoeZoneSelected = function (payload) {
          handleEntsoeZoneSelected(payload);
        };

        window.addEventListener('message', function (event) {
          if (!event) {
            return;
          }
          if (entsoeFullFrame && event.source && event.source !== entsoeFullFrame.contentWindow) {
            return;
          }
          handleEntsoeZoneSelected(event.data);
        });

        async function loadEntsoeMap() {
          if (entsoeAreaMap) {
            return entsoeAreaMap;
          }
          try {
            const response = await fetch('../assets/entsoe_area_map.json', { cache: 'no-cache' });
            if (!response.ok) {
              throw new Error('Failed to load entsoe_area_map.json');
            }
            entsoeAreaMap = await response.json();
            return entsoeAreaMap;
          } catch (error) {
            console.error('Failed to load entsoe_area_map.json', error);
            if (priceSourceStatusElement && !priceSourceStatusElement.textContent) {
              priceSourceStatusElement.textContent = 'Could not auto-detect ENTSO-E zone. Please set it manually in the ENTSO-E section.';
            }
            return null;
          }
        }

        async function ensureEntsoeDefaultZone(force = false) {
          if (entsoeAutoSelectionDone && !force) {
            return null;
          }
          if (!force && entsoeAutoSelectionDone) {
            return null;
          }
          entsoeAutoSelectionDone = true;
          try {
            const stored = await new Promise((resolve) => {
              Homey.get('entsoe_area_eic', function(err, value) {
                if (err) {
                  console.warn('Failed to read entsoe_area_eic', err);
                  resolve(null);
                  return;
                }
                resolve(value);
              });
            });
            if (typeof stored === 'string' && stored.trim().length > 0) {
              updateEntsoeZoneInput(stored.trim(), 'Using stored ENTSO-E zone.');
              return stored.trim();
            }

            const map = await loadEntsoeMap();
            if (!map) {
              return null;
            }

            const language = navigator.language || navigator.userLanguage || '';
            const parts = language.split('-');
            const iso = parts.length > 1 ? parts[1].toUpperCase() : parts[0]?.toUpperCase() || '';
            const list = iso && map[iso] ? map[iso] : null;
            if (!list || list.length === 0) {
              if (priceSourceStatusElement && !priceSourceStatusElement.textContent) {
                priceSourceStatusElement.textContent = 'Select your ENTSO-E zone in the ENTSO-E pricing section.';
              }
              return null;
            }

            const eic = list[0];
            saveEntsoeZone(eic, { silent: true });
            updateEntsoeZoneInput(eic, `ENTSO-E zone set to ${iso} (${eic}). Adjust if needed.`);
            return eic;
          } catch (error) {
            console.error('Failed to auto-select ENTSO-E zone', error);
            if (entsoeZoneStatus && !entsoeZoneStatus.textContent) {
              entsoeZoneStatus.textContent = 'Unable to auto-detect zone; please enter it manually.';
            }
            return null;
          }
        }

        function renderPriceSource(value) {
          const selection = value === 'tibber' ? 'tibber' : 'entsoe';
          if (priceSourceTibberElement) {
            priceSourceTibberElement.checked = selection === 'tibber';
          }
          if (priceSourceEntsoeElement) {
            priceSourceEntsoeElement.checked = selection === 'entsoe';
          }
          if (entsoeQuickDetails) {
            entsoeQuickDetails.open = selection === 'entsoe';
          }
          const enableTibberInputs = selection === 'tibber';
          if (tibberTokenElement) {
            tibberTokenElement.disabled = !enableTibberInputs;
          }
          if (tibberTokenGroup) {
            if (enableTibberInputs) {
              tibberTokenGroup.classList.remove('disabled');
            } else {
              tibberTokenGroup.classList.add('disabled');
            }
          }
          if (priceSourceStatusElement) {
            priceSourceStatusElement.textContent = selection === 'tibber'
              ? 'Using Tibber data. Remember to keep your token up to date.'
              : 'Using ENTSO-E day-ahead prices provided by the app.';
          }

          if (selection === 'entsoe') {
            ensureEntsoeDefaultZone();
          }
          
          // Update consumer markup visibility based on price source
          updateConsumerMarkupVisibility();
        }

        // Consumer markup helper functions (defined before use)
        function updateConsumerMarkupVisibility() {
          const isEnabled = enableConsumerMarkupElement && enableConsumerMarkupElement.checked;
          const isEntsoeSelected = priceSourceEntsoeElement && priceSourceEntsoeElement.checked;
          
          // Only show consumer markup settings when ENTSO-E is selected
          if (consumerMarkupSection) {
            consumerMarkupSection.style.display = isEntsoeSelected ? 'block' : 'none';
          }
          if (consumerMarkupConfigSection) {
            consumerMarkupConfigSection.style.display = (isEntsoeSelected && isEnabled) ? 'block' : 'none';
          }
          if (markupCurrencySection) {
            markupCurrencySection.style.display = (isEntsoeSelected && isEnabled) ? 'block' : 'none';
          }
        }

        function loadDefaultConsumerMarkupConfig() {
          const defaultConfig = {
            "SE": {
              "gridFee": 0.030,
              "energyTax": 0.036,
              "retailMarkup": 0.010,
              "vatRate": 1.25,
              "description": "Sweden - typical residential"
            },
            "DE": {
              "gridFee": 0.070,
              "energyTax": 0.025,
              "retailMarkup": 0.015,
              "vatRate": 1.19,
              "description": "Germany - typical residential"
            },
            "NO": {
              "gridFee": 0.035,
              "energyTax": 0.017,
              "retailMarkup": 0.008,
              "vatRate": 1.25,
              "description": "Norway - typical residential"
            },
            "DK": {
              "gridFee": 0.045,
              "energyTax": 0.089,
              "retailMarkup": 0.012,
              "vatRate": 1.25,
              "description": "Denmark - typical residential"
            },
            "FR": {
              "gridFee": 0.045,
              "energyTax": 0.022,
              "retailMarkup": 0.012,
              "vatRate": 1.20,
              "description": "France - typical residential"
            },
            "NL": {
              "gridFee": 0.055,
              "energyTax": 0.030,
              "retailMarkup": 0.018,
              "vatRate": 1.21,
              "description": "Netherlands - typical residential"
            },
            "BE": {
              "gridFee": 0.048,
              "energyTax": 0.028,
              "retailMarkup": 0.015,
              "vatRate": 1.21,
              "description": "Belgium - typical residential"
            },
            "AT": {
              "gridFee": 0.038,
              "energyTax": 0.015,
              "retailMarkup": 0.012,
              "vatRate": 1.20,
              "description": "Austria - typical residential"
            },
            "CH": {
              "gridFee": 0.065,
              "energyTax": 0.023,
              "retailMarkup": 0.020,
              "vatRate": 1.077,
              "description": "Switzerland - typical residential"
            },
            "FI": {
              "gridFee": 0.042,
              "energyTax": 0.027,
              "retailMarkup": 0.015,
              "vatRate": 1.24,
              "description": "Finland - typical residential"
            },
            "PL": {
              "gridFee": 0.025,
              "energyTax": 0.012,
              "retailMarkup": 0.008,
              "vatRate": 1.23,
              "description": "Poland - typical residential"
            },
            "CZ": {
              "gridFee": 0.030,
              "energyTax": 0.018,
              "retailMarkup": 0.010,
              "vatRate": 1.21,
              "description": "Czech Republic - typical residential"
            },
            "IT": {
              "gridFee": 0.055,
              "energyTax": 0.035,
              "retailMarkup": 0.018,
              "vatRate": 1.22,
              "description": "Italy - typical residential"
            },
            "ES": {
              "gridFee": 0.045,
              "energyTax": 0.051,
              "retailMarkup": 0.015,
              "vatRate": 1.21,
              "description": "Spain - typical residential"
            },
            "PT": {
              "gridFee": 0.042,
              "energyTax": 0.034,
              "retailMarkup": 0.013,
              "vatRate": 1.23,
              "description": "Portugal - typical residential"
            },
            "GB": {
              "gridFee": 0.050,
              "energyTax": 0.006,
              "retailMarkup": 0.020,
              "vatRate": 1.05,
              "description": "United Kingdom - typical residential"
            },
            "EE": {
              "gridFee": 0.035,
              "energyTax": 0.007,
              "retailMarkup": 0.012,
              "vatRate": 1.20,
              "description": "Estonia - typical residential"
            },
            "LV": {
              "gridFee": 0.038,
              "energyTax": 0.009,
              "retailMarkup": 0.014,
              "vatRate": 1.21,
              "description": "Latvia - typical residential"
            },
            "LT": {
              "gridFee": 0.040,
              "energyTax": 0.011,
              "retailMarkup": 0.016,
              "vatRate": 1.21,
              "description": "Lithuania - typical residential"
            },
            "SK": {
              "gridFee": 0.028,
              "energyTax": 0.015,
              "retailMarkup": 0.009,
              "vatRate": 1.20,
              "description": "Slovakia - typical residential"
            },
            "SI": {
              "gridFee": 0.045,
              "energyTax": 0.030,
              "retailMarkup": 0.012,
              "vatRate": 1.22,
              "description": "Slovenia - typical residential"
            },
            "HU": {
              "gridFee": 0.022,
              "energyTax": 0.008,
              "retailMarkup": 0.007,
              "vatRate": 1.27,
              "description": "Hungary - typical residential"
            },
            "IE": {
              "gridFee": 0.048,
              "energyTax": 0.009,
              "retailMarkup": 0.018,
              "vatRate": 1.135,
              "description": "Ireland - typical residential"
            },
            "RO": {
              "gridFee": 0.028,
              "energyTax": 0.012,
              "retailMarkup": 0.010,
              "vatRate": 1.19,
              "description": "Romania - typical residential"
            },
            "BG": {
              "gridFee": 0.025,
              "energyTax": 0.008,
              "retailMarkup": 0.008,
              "vatRate": 1.20,
              "description": "Bulgaria - typical residential"
            },
            "HR": {
              "gridFee": 0.032,
              "energyTax": 0.014,
              "retailMarkup": 0.012,
              "vatRate": 1.25,
              "description": "Croatia - typical residential"
            },
            "GR": {
              "gridFee": 0.038,
              "energyTax": 0.025,
              "retailMarkup": 0.015,
              "vatRate": 1.24,
              "description": "Greece - typical residential"
            },
            "RS": {
              "gridFee": 0.020,
              "energyTax": 0.006,
              "retailMarkup": 0.008,
              "vatRate": 1.20,
              "description": "Serbia - typical residential"
            },
            "BA": {
              "gridFee": 0.022,
              "energyTax": 0.008,
              "retailMarkup": 0.009,
              "vatRate": 1.17,
              "description": "Bosnia and Herzegovina - typical residential"
            },
            "ME": {
              "gridFee": 0.025,
              "energyTax": 0.005,
              "retailMarkup": 0.010,
              "vatRate": 1.21,
              "description": "Montenegro - typical residential"
            },
            "MK": {
              "gridFee": 0.018,
              "energyTax": 0.004,
              "retailMarkup": 0.007,
              "vatRate": 1.18,
              "description": "North Macedonia - typical residential"
            },
            "AL": {
              "gridFee": 0.015,
              "energyTax": 0.003,
              "retailMarkup": 0.006,
              "vatRate": 1.20,
              "description": "Albania - typical residential"
            },
            "TR": {
              "gridFee": 0.012,
              "energyTax": 0.005,
              "retailMarkup": 0.008,
              "vatRate": 1.18,
              "description": "Turkey - typical residential"
            },
            "default": {
              "gridFee": 0.040,
              "energyTax": 0.020,
              "retailMarkup": 0.010,
              "vatRate": 1.20,
              "description": "EU average approximation"
            }
          };

          const configJson = JSON.stringify(defaultConfig, null, 2);
          if (consumerMarkupConfigElement) {
            consumerMarkupConfigElement.value = configJson;
            Homey.set("consumer_markup_config", configJson, function (err) {
              if (err) console.error('Error saving default consumer_markup_config:', err);
            });
            validateConsumerMarkupConfig();
          }
        }

        function validateConsumerMarkupConfig() {
          if (!consumerMarkupConfigElement || !consumerMarkupStatus) return;
          
          const value = consumerMarkupConfigElement.value.trim();
          if (!value) {
            consumerMarkupStatus.textContent = 'Configuration is empty. Click "Load Defaults" to get started.';
            consumerMarkupStatus.style.color = '#999';
            return;
          }

          try {
            const config = JSON.parse(value);
            const countries = Object.keys(config);
            const validCountries = countries.filter(country => {
              const c = config[country];
              return c && typeof c.gridFee === 'number' && typeof c.energyTax === 'number' && 
                     typeof c.retailMarkup === 'number' && typeof c.vatRate === 'number';
            });
            
            if (validCountries.length === 0) {
              consumerMarkupStatus.textContent = 'Invalid configuration: No valid country entries found.';
              consumerMarkupStatus.style.color = '#d32f2f';
            } else {
              consumerMarkupStatus.textContent = `Valid configuration with ${validCountries.length} countries: ${validCountries.join(', ')}`;
              consumerMarkupStatus.style.color = '#2e7d32';
            }
          } catch (error) {
            consumerMarkupStatus.textContent = 'Invalid JSON format. Please check syntax.';
            consumerMarkupStatus.style.color = '#d32f2f';
          }
        }

        function savePriceSource(value) {
          const selection = value === 'entsoe' ? 'entsoe' : 'tibber';
          Homey.set('price_data_source', selection, function (err) {
            if (err) {
              console.error('Failed to save price_data_source', err);
              if (priceSourceStatusElement) {
                priceSourceStatusElement.textContent = 'Failed to save price source preference.';
              }
              return;
            }
            renderPriceSource(selection);
            if (priceSourceStatusElement) {
              priceSourceStatusElement.textContent = selection === 'tibber'
                ? 'Saved: Tibber API selected for pricing.'
                : 'Saved: ENTSO-E pricing selected.';
            }
          });
        }

        if (priceSourceTibberElement) {
          priceSourceTibberElement.addEventListener('change', function () {
            if (priceSourceTibberElement.checked) {
              savePriceSource('tibber');
              updateConsumerMarkupVisibility();
            }
          });
        }
        if (priceSourceEntsoeElement) {
          priceSourceEntsoeElement.addEventListener('change', function () {
            if (priceSourceEntsoeElement.checked) {
              savePriceSource('entsoe');
              updateConsumerMarkupVisibility();
            }
          });
        }

        if (entsoeZoneInput) {
          entsoeZoneInput.addEventListener('change', function () {
            saveEntsoeZone(entsoeZoneInput.value);
          });
        }

        if (entsoeAutoButton) {
          entsoeAutoButton.addEventListener('click', function () {
            ensureEntsoeDefaultZone(true);
          });
        }

        // Consumer markup event handlers
        if (enableConsumerMarkupElement) {
          enableConsumerMarkupElement.addEventListener('change', function () {
            Homey.set("enable_consumer_markup", enableConsumerMarkupElement.checked, function (err) {
              if (err) console.error('Error saving enable_consumer_markup:', err);
            });
            updateConsumerMarkupVisibility();
          });
        }

        if (consumerMarkupConfigElement) {
          consumerMarkupConfigElement.addEventListener('change', function () {
            const value = consumerMarkupConfigElement.value.trim();
            Homey.set("consumer_markup_config", value, function (err) {
              if (err) console.error('Error saving consumer_markup_config:', err);
            });
            validateConsumerMarkupConfig();
          });
        }

        if (markupCurrencyUnitElement) {
          markupCurrencyUnitElement.addEventListener('change', function () {
            Homey.set("markup_currency_unit", markupCurrencyUnitElement.value, function (err) {
              if (err) console.error('Error saving markup_currency_unit:', err);
            });
          });
        }

        if (loadMarkupDefaultsButton) {
          loadMarkupDefaultsButton.addEventListener('click', function () {
            loadDefaultConsumerMarkupConfig();
          });
        }

        let entsoeFrameLoaded = false;
        if (entsoeOpenFullButton) {
          entsoeOpenFullButton.addEventListener('click', function () {
            if (!entsoeFullContainer) {
              return;
            }
            const isHidden = entsoeFullContainer.hasAttribute('hidden');
            if (isHidden) {
              entsoeFullContainer.removeAttribute('hidden');
              if (entsoeFullFrame && !entsoeFrameLoaded) {
                entsoeFullFrame.src = '../assets/settings/index.html';
                entsoeFrameLoaded = true;
              }
              entsoeOpenFullButton.textContent = 'Hide full ENTSO-E settings';
              entsoeOpenFullButton.setAttribute('aria-expanded', 'true');
            } else {
              entsoeFullContainer.setAttribute('hidden', '');
              entsoeOpenFullButton.textContent = 'Open full ENTSO-E settings';
              entsoeOpenFullButton.setAttribute('aria-expanded', 'false');
            }
          });
        }

        // Hot water tank elements
        const enableTankControlElement = document.getElementById("enable_tank_control");
        const minTankTempElement = document.getElementById("min_tank_temp");
        const maxTankTempElement = document.getElementById("max_tank_temp");
        const tankTempStepElement = document.getElementById("tank_temp_step");
        const tankFieldset = document.getElementById("tank_fieldset");
        const tankCapabilityWarning = document.getElementById("tank_capability_warning");

        // Costs & consumption elements
        const gridFeeElement = document.getElementById("grid_fee_per_kwh");

        // Engine elements
        const deadbandElement = document.getElementById("deadband_c");
        const minChangeMinutesElement = document.getElementById("min_setpoint_change_minutes");
        const extremeMinElement = document.getElementById("extreme_weather_min_temp");
        const occupiedElement = document.getElementById("occupied");
        const comfortLowerOccElement = document.getElementById("comfort_lower_occupied");
        const comfortUpperOccElement = document.getElementById("comfort_upper_occupied");
        const comfortLowerAwayElement = document.getElementById("comfort_lower_away");
        const comfortUpperAwayElement = document.getElementById("comfort_upper_away");
        const preheatEnableElement = document.getElementById("preheat_enable");
        const preheatHorizonElement = document.getElementById("preheat_horizon_hours");
        const preheatPercentileElement = document.getElementById("preheat_cheap_percentile");

        // Weather location warning helper
        function updateWeatherLocationWarning() {
          const warn = document.getElementById('weather_location_warning');
          if (!warn || !useWeatherDataElement || !latitudeElement || !longitudeElement) return;
          const enabled = useWeatherDataElement.checked;
          const latOk = latitudeElement.value !== '' && !isNaN(parseFloat(latitudeElement.value));
          const lonOk = longitudeElement.value !== '' && !isNaN(parseFloat(longitudeElement.value));
          warn.style.display = enabled && (!latOk || !lonOk) ? 'block' : 'none';
        }
        useWeatherDataElement.addEventListener('change', updateWeatherLocationWarning);
        latitudeElement.addEventListener('input', updateWeatherLocationWarning);
        longitudeElement.addEventListener('input', updateWeatherLocationWarning);
        
        // Removed: unused hot water pattern inputs (UI-only previously)
        const resetPatternsButton = document.getElementById("reset_patterns");
        const clearAllDataButton = document.getElementById("clear_all_data");
        // Buttons now use onclick attributes with global functions

        // Load current settings
        Homey.get("price_data_source", function (err, value) {
          if (err) {
            console.error('Failed to load price_data_source', err);
            renderPriceSource('entsoe');
            return;
          }
          renderPriceSource(value);
          if (value === 'entsoe') {
            ensureEntsoeDefaultZone();
          }
        });

        Homey.get("melcloud_user", function (err, value) {
          if (err) return Homey.alert(err);
          if (value) melcloudUserElement.value = value;
        });

        Homey.get("melcloud_pass", function (err, value) {
          if (err) return Homey.alert(err);
          if (value) melcloudPassElement.value = value;
        });

        // Store the saved device and building IDs to use after loading the device list
        let savedDeviceId = null;
        let savedBuildingId = null;

        const loadDeviceIdPromise = new Promise((resolve) => {
          Homey.get("device_id", function (err, value) {
            if (err) {
              Homey.alert(err);
              return resolve();
            }
            if (value) {
              savedDeviceId = value;
              manualDeviceIdElement.value = value;
            }
            resolve();
          });
        });

        const loadBuildingIdPromise = new Promise((resolve) => {
          Homey.get("building_id", function (err, value) {
            if (err) {
              Homey.alert(err);
              return resolve();
            }
            if (value) {
              savedBuildingId = value;
              manualBuildingIdElement.value = value;
            }
            resolve();
          });
        });

        Promise.all([loadDeviceIdPromise, loadBuildingIdPromise]).then(() => {
          loadDeviceList(savedDeviceId, savedBuildingId);
        });

        Homey.get("tibber_token", function (err, value) {
          if (err) return Homey.alert(err);
          if (value) tibberTokenElement.value = value;
        });

        Homey.get('entsoe_area_eic', function (err, value) {
          if (!err && typeof value === 'string') {
            updateEntsoeZoneInput(value);
          }
        });

        // Load costs & consumption settings
        Homey.get("grid_fee_per_kwh", function (err, value) {
          if (hasValidValue(err, value)) gridFeeElement.value = value;
        });

        // Load consumer markup settings
        Homey.get("enable_consumer_markup", function (err, value) {
          if (!err && value !== undefined && value !== null && value !== "") {
            enableConsumerMarkupElement.checked = !!value;
            updateConsumerMarkupVisibility();
          }
        });

        Homey.get("consumer_markup_config", function (err, value) {
          if (!err && typeof value === 'string' && value.trim()) {
            consumerMarkupConfigElement.value = value;
            validateConsumerMarkupConfig();
          } else {
            loadDefaultConsumerMarkupConfig();
          }
        });

        Homey.get("markup_currency_unit", function (err, value) {
          if (!err && typeof value === 'string') {
            markupCurrencyUnitElement.value = value;
          }
        });

        Homey.get("temp_step_max", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null && value !== "") tempStepMaxElement.value = value;
        });

        // Load engine settings
        Homey.get("deadband_c", function (err, value) { if (hasValidValue(err, value)) deadbandElement.value = value; });
        Homey.get("min_setpoint_change_minutes", function (err, value) { if (hasValidValue(err, value)) minChangeMinutesElement.value = value; });
        Homey.get("extreme_weather_min_temp", function (err, value) { if (hasValidValue(err, value)) extremeMinElement.value = value; });
        Homey.get("occupied", function (err, value) { if (!err && value !== undefined && value !== null && value !== "") occupiedElement.checked = !!value; });
        Homey.get("comfort_lower_occupied", function (err, value) { if (hasValidValue(err, value)) comfortLowerOccElement.value = value; });
        Homey.get("comfort_upper_occupied", function (err, value) { if (hasValidValue(err, value)) comfortUpperOccElement.value = value; });
        Homey.get("comfort_lower_away", function (err, value) { if (hasValidValue(err, value)) comfortLowerAwayElement.value = value; });
        Homey.get("comfort_upper_away", function (err, value) { if (hasValidValue(err, value)) comfortUpperAwayElement.value = value; });
        Homey.get("preheat_enable", function (err, value) { if (!err && value !== undefined && value !== null && value !== "") preheatEnableElement.checked = !!value; });
        Homey.get("preheat_horizon_hours", function (err, value) { if (hasValidValue(err, value)) preheatHorizonElement.value = value; });
        Homey.get("preheat_cheap_percentile", function (err, value) { if (hasValidValue(err, value)) preheatPercentileElement.value = value; });

        Homey.get("log_level", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null && value !== "") logLevelElement.value = value;
        });

        Homey.get("notify_on_success", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null && value !== "") notifyOnSuccessElement.checked = !!value;
        });

        Homey.get("timeline_verbosity", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null && value !== "") {
            timelineVerbosityElement.value = value;
          } else {
            // Default to 'standard' if not set
            timelineVerbosityElement.value = 'standard';
          }
        });

        // Show/hide debug option based on log level
        function updateTimelineDebugOption() {
          const debugOption = document.getElementById("timeline_debug_option");
          if (debugOption && logLevelElement) {
            if (logLevelElement.value === "0") { // Debug log level
              debugOption.style.display = "block";
            } else {
              debugOption.style.display = "none";
              // If debug was selected but log level changed, reset to standard
              if (timelineVerbosityElement.value === "debug") {
                timelineVerbosityElement.value = "standard";
              }
            }
          }
        }

        if (logLevelElement) {
          logLevelElement.addEventListener('change', updateTimelineDebugOption);
          // Update on initial load
          setTimeout(updateTimelineDebugOption, 100);
        }

        Homey.get("currency", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null) currencyCodeElement.value = value;
        });

        Homey.get("use_weather_data", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null && value !== "") useWeatherDataElement.checked = !!value;
          updateWeatherLocationWarning();
        });

        Homey.get("latitude", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null && value !== "") latitudeElement.value = value;
          updateWeatherLocationWarning();
        });

        Homey.get("longitude", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null && value !== "") longitudeElement.value = value;
          updateWeatherLocationWarning();
        });

        // Load comfort profile settings
        Homey.get("day_start_hour", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null && value !== "") dayStartHourElement.value = value;
        });

        Homey.get("day_end_hour", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null && value !== "") dayEndHourElement.value = value;
        });

        Homey.get("night_temp_reduction", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null && value !== "") nightTempReductionElement.value = value;
        });

        Homey.get("pre_heat_hours", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null && value !== "") preHeatHoursElement.value = value;
        });

        // Load time zone settings
        Homey.get("time_zone_offset", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null && value !== "") timeZoneOffsetElement.value = value;
        });

        Homey.get("use_dst", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null && value !== "") useDstElement.checked = !!value;
        });

        Homey.get("time_zone_name", function (err, value) {
          if (err) return Homey.alert(err);
          if (timeZoneNameElement) {
            const tzName = typeof value === 'string' ? value : '';
            
            // Auto-detect timezone for new users
            if (!tzName) {
              try {
                const autoDetected = Intl.DateTimeFormat().resolvedOptions().timeZone;
                if (autoDetected) {
                  timeZoneNameElement.value = autoDetected;
                  updateTimezonePreview(autoDetected);
                  if (timeZoneNameStatusElement) {
                    timeZoneNameStatusElement.textContent = `‚úÖ Auto-detected: ${autoDetected}`;
                    timeZoneNameStatusElement.style.color = '#00aa44';
                  }
                  // Save the auto-detected timezone
                  save('time_zone_name', autoDetected);
                  console.log('Auto-detected and saved timezone:', autoDetected);
                  return;
                }
              } catch (error) {
                console.warn('Failed to auto-detect timezone:', error);
              }
            }
            
            timeZoneNameElement.value = tzName;
            if (tzName) {
              updateTimezonePreview(tzName);
              if (timeZoneNameStatusElement) {
                timeZoneNameStatusElement.textContent = `‚úÖ Using timezone: ${tzName}`;
                timeZoneNameStatusElement.style.color = '#00aa44';
              }
            } else {
              if (timeZoneNameStatusElement) {
                timeZoneNameStatusElement.textContent = 'Will use manual UTC offset if configured';
                timeZoneNameStatusElement.style.color = '#888';
              }
            }
          }
        });

        // Load Zone2 settings
        Homey.get("enable_zone2", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null && value !== "") {
            enableZone2Element.checked = !!value;
            zone2SettingsDiv.style.display = value ? 'block' : 'none';
          }
        });

        Homey.get("min_temp_zone2", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null && value !== "") minTempZone2Element.value = value;
        });

        Homey.get("max_temp_zone2", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null && value !== "") maxTempZone2Element.value = value;
        });

        Homey.get("temp_step_zone2", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null && value !== "") tempStepZone2Element.value = value;
        });

        // Manual entry controls are not persisted; default to hidden
        showManualEntryElement.checked = false;
        manualIdEntryDiv.style.display = 'none';

        // Load hot water tank settings
        Homey.get("enable_tank_control", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null && value !== "") enableTankControlElement.checked = !!value;
        });

        Homey.get("min_tank_temp", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null && value !== "") minTankTempElement.value = value;
        });

        Homey.get("max_tank_temp", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null && value !== "") maxTankTempElement.value = value;
        });

        Homey.get("tank_temp_step", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null && value !== "") tankTempStepElement.value = value;
        });
        
        // Removed: loads for unused hot water pattern settings

        // Load COP settings
        Homey.get("cop_weight", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null && value !== "") copWeightElement.value = value;
        });

        Homey.get("auto_seasonal_mode", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null && value !== "") {
            autoSeasonalModeElement.checked = !!value;
            // Show/hide summer mode based on auto seasonal mode
            summerModeContainer.style.opacity = value ? '0.5' : '1';
            summerModeElement.disabled = value;
          }
        });

        Homey.get("summer_mode", function (err, value) {
          if (err) return Homey.alert(err);
          if (value !== undefined && value !== null && value !== "") summerModeElement.checked = !!value;
        });

        // Default values are now provided directly in HTML form fields

        // No need for complex timing logic - defaults are in HTML now

        // Function to load the device list and select the saved device and building IDs
        function loadDeviceList(savedDeviceId, savedBuildingId) {
          console.log('Loading device list with saved IDs:', { savedDeviceId, savedBuildingId });

          // Show loading state
          deviceRefreshStatus.textContent = "Loading devices...";

          // Call the API to get the device list
          HomeyInstance.api('GET', '/getDeviceList', {}, function(err, result) {
            refreshDevicesButton.disabled = false;

            if (err) {
              console.error('Error getting device list:', err);
              deviceRefreshStatus.textContent = "Error: " + err.message;

              // If we can't load the device list but have saved IDs, show the manual entry fields
              if (savedDeviceId || savedBuildingId) {
                showManualEntryElement.checked = true;
                manualIdEntryDiv.style.display = 'block';
              }

              return;
            }

            const normalized = normalizeDeviceListResponse(result);
            console.log('Device list retrieved successfully:', {
              success: normalized.success,
              devices: normalized.devices.length,
              buildings: normalized.buildings.length
            });

            if (!normalized.success && normalized.message) {
              deviceRefreshStatus.textContent = "Error: " + normalized.message;
            }

            // Clear existing options
            while (buildingIdElement.options.length > 1) {
              buildingIdElement.remove(1);
            }

            while (deviceIdElement.options.length > 1) {
              deviceIdElement.remove(1);
            }

            const savedBuildingIdStr = savedBuildingId != null ? String(savedBuildingId) : null;
            const savedDeviceIdStr = savedDeviceId != null ? String(savedDeviceId) : null;

            // Add buildings to the dropdown
            let foundSavedBuilding = false;
            normalized.buildings.forEach(building => {
              if (!building) return;
              const buildingIdStr = building.id !== undefined && building.id !== null
                ? String(building.id)
                : '';
              if (!buildingIdStr) return;

              const option = document.createElement('option');
              option.value = buildingIdStr;
              option.text = building.name || `Building ${buildingIdStr}`;
              buildingIdElement.add(option);

              if (savedBuildingIdStr && buildingIdStr === savedBuildingIdStr) {
                foundSavedBuilding = true;
                savedBuildingId = buildingIdStr;
              }
            });

            const zone2Label = document.querySelector('label[for="enable_zone2"]');
            enableZone2Element.disabled = true;
            if (zone2Label) zone2Label.style.opacity = 0.5;
            zone2Fieldset.style.display = 'none';
            if (!enableZone2Element.checked) {
              zone2SettingsDiv.style.display = 'none';
            }
            tankFieldset.style.display = 'none';
            tankCapabilityWarning.style.display = 'none';

            // Add devices to the dropdown
            let foundSavedDevice = false;
            normalized.devices.forEach(device => {
              if (!device) return;
              const deviceIdStr = device.id !== undefined && device.id !== null
                ? String(device.id)
                : '';
              if (!deviceIdStr) return;

              const option = document.createElement('option');
              option.value = deviceIdStr;
              option.text = device.name || `Device ${deviceIdStr}`;
              const buildingIdStr = device.buildingId !== undefined && device.buildingId !== null
                ? String(device.buildingId)
                : '';
              if (buildingIdStr) option.dataset.buildingId = buildingIdStr;
              option.dataset.hasZone1 = device.hasZone1 ? 'true' : 'false';
              option.dataset.hasZone2 = device.hasZone2 ? 'true' : 'false';
              option.dataset.hasTank = device.hasTank ? 'true' : 'false';
              if (device.type) option.dataset.type = device.type;
              if (device.SetTankWaterTemperature !== undefined) option.dataset.settankwatertemperature = String(device.SetTankWaterTemperature);
              if (device.TankWaterTemperature !== undefined) option.dataset.tankwatertemperature = String(device.TankWaterTemperature);
              deviceIdElement.add(option);

              if (savedDeviceIdStr && deviceIdStr === savedDeviceIdStr) {
                foundSavedDevice = true;
                deviceIdElement.value = deviceIdStr;
                savedDeviceId = deviceIdStr;
                if (buildingIdStr) {
                  buildingIdElement.value = buildingIdStr;
                  savedBuildingId = buildingIdStr;
                }

                const hasZone2 = option.dataset.hasZone2 === 'true';
                if (hasZone2) {
                  enableZone2Element.disabled = false;
                  if (zone2Label) zone2Label.style.opacity = 1;
                  zone2Fieldset.style.display = '';
                } else {
                  enableZone2Element.disabled = true;
                  enableZone2Element.checked = false;
                  zone2SettingsDiv.style.display = 'none';
                  if (zone2Label) zone2Label.style.opacity = 0.5;
                  zone2Fieldset.style.display = 'none';
                }

                const typeString = (option.dataset.type || '').toString().toLowerCase();
                const typeHasTank = typeString.includes('atw') || typeString.includes('boiler') || typeString.includes('tank') || typeString.includes('heat_pump');
                const deviceHasTankData = option.dataset.settankwatertemperature !== undefined
                  || option.dataset.tankwatertemperature !== undefined
                  || option.dataset.hastank === 'true';
                const likelyHasTank = typeHasTank || deviceHasTankData;

                if (likelyHasTank) {
                  tankFieldset.style.display = '';
                  tankCapabilityWarning.style.display = 'none';
                } else {
                  tankFieldset.style.display = 'none';
                  enableTankControlElement.checked = false;
                }
              }
            });

            if (normalized.devices.length > 0) {
              deviceRefreshStatus.textContent = `Found ${normalized.devices.length} device${normalized.devices.length === 1 ? '' : 's'}`;
            } else if (normalized.success) {
              deviceRefreshStatus.textContent = "No devices found";
            } else if (!normalized.message) {
              deviceRefreshStatus.textContent = "Failed to load devices";
            }

            if (!normalized.success && normalized.message) {
              showManualEntryElement.checked = true;
              manualIdEntryDiv.style.display = 'block';
            } else if ((savedDeviceIdStr && !foundSavedDevice) || (savedBuildingIdStr && !foundSavedBuilding)) {
              showManualEntryElement.checked = true;
              manualIdEntryDiv.style.display = 'block';
            } else if (!showManualEntryElement.checked) {
              manualIdEntryDiv.style.display = 'none';
            }
          });
        }

        // Add event listener for the refresh devices button
        refreshDevicesButton.addEventListener('click', function(e) {
          e.preventDefault();

          // Disable the button and show loading state
          refreshDevicesButton.disabled = true;
          deviceRefreshStatus.textContent = "Saving credentials...";

          // Get credentials from form inputs
          const melcloudUser = melcloudUserElement.value.trim();
          const melcloudPass = melcloudPassElement.value;

          // Validate credentials
          if (!melcloudUser || !melcloudPass) {
            refreshDevicesButton.disabled = false;
            deviceRefreshStatus.textContent = "Error: Please enter both email and password";
            return;
          }

          // Save credentials to Homey settings first
          Homey.set("melcloud_user", melcloudUser, function (err) {
            if (err) {
              refreshDevicesButton.disabled = false;
              deviceRefreshStatus.textContent = "Error saving email: " + err.message;
              return;
            }

            Homey.set("melcloud_pass", melcloudPass, function (err) {
              if (err) {
                refreshDevicesButton.disabled = false;
                deviceRefreshStatus.textContent = "Error saving password: " + err.message;
                return;
              }

              // Credentials saved successfully, now load devices
              deviceRefreshStatus.textContent = "Loading devices...";

              // Get the current saved IDs
              const currentDeviceId = deviceIdElement.value || manualDeviceIdElement.value;
              const currentBuildingId = buildingIdElement.value || manualBuildingIdElement.value;

              // Call the loadDeviceList function
              loadDeviceList(currentDeviceId, currentBuildingId);
            });
          });
        });

        // Add event listener for the device selection to update building selection
        deviceIdElement.addEventListener('change', function() {
          const selectedOption = deviceIdElement.options[deviceIdElement.selectedIndex];

          if (selectedOption && selectedOption.dataset.buildingId) {
            buildingIdElement.value = selectedOption.dataset.buildingId;

            // Check if the device has Zone2 and enable/disable the Zone2 settings accordingly
            if (selectedOption.dataset.hasZone2 === "true") {
              enableZone2Element.disabled = false;
              document.querySelector('label[for="enable_zone2"]').style.opacity = 1;
              zone2Fieldset.style.display = '';
            } else {
              enableZone2Element.disabled = true;
              enableZone2Element.checked = false;
              zone2SettingsDiv.style.display = 'none';
              document.querySelector('label[for="enable_zone2"]').style.opacity = 0.5;
              zone2Fieldset.style.display = 'none';
            }

            // Tank capability (check by device type and actual tank temperature support)
            const t = (selectedOption.dataset.type || '').toString().toLowerCase();
            const typeHasTank = t.includes('atw') || t.includes('boiler') || t.includes('tank') || t.includes('heat_pump');
            const deviceHasTankData = selectedOption.dataset.settankwatertemperature !== undefined || selectedOption.dataset.tankwatertemperature !== undefined || selectedOption.dataset.hastank === "true";
            const likelyHasTank = typeHasTank || deviceHasTankData;
            
            if (likelyHasTank) {
              tankFieldset.style.display = '';
              tankCapabilityWarning.style.display = 'none';
            } else {
              tankFieldset.style.display = 'none';
              enableTankControlElement.checked = false;
            }
          }
        });

        // Add event listener for the show manual entry checkbox
        showManualEntryElement.addEventListener('change', function() {
          manualIdEntryDiv.style.display = this.checked ? 'block' : 'none';
        });

        // Add event listener for the enable Zone2 checkbox
        enableZone2Element.addEventListener('change', function() {
          zone2SettingsDiv.style.display = this.checked ? 'block' : 'none';
        });

        // Add event listener for the Auto Seasonal Mode checkbox
        autoSeasonalModeElement.addEventListener('change', function() {
          // When Auto Seasonal Mode is enabled, disable Summer Mode
          summerModeElement.disabled = this.checked;
          summerModeContainer.style.opacity = this.checked ? '0.5' : '1';
        });

        // Add event listener for the detect location button
        detectLocationButton.addEventListener('click', function(e) {
          e.preventDefault();

          // Show a message that this is a browser-based feature
          Homey.alert('This feature uses your browser\'s location. Please allow location access when prompted.');

          // Use browser geolocation API
          if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
              function(position) {
                // Success callback
                latitudeElement.value = position.coords.latitude;
                longitudeElement.value = position.coords.longitude;
                Homey.alert('Location detected successfully! Please save your settings.');
              },
              function(error) {
                // Error callback
                let errorMessage = 'Could not detect your location. ';
                switch(error.code) {
                  case error.PERMISSION_DENIED:
                    errorMessage += 'Location permission was denied.';
                    break;
                  case error.POSITION_UNAVAILABLE:
                    errorMessage += 'Location information is unavailable.';
                    break;
                  case error.TIMEOUT:
                    errorMessage += 'The request to get location timed out.';
                    break;
                  default:
                    errorMessage += 'An unknown error occurred.';
                    break;
                }
                Homey.alert(errorMessage);
              }
            );
          } else {
            Homey.alert('Geolocation is not supported by your browser. Please enter coordinates manually.');
          }
        });

        // Save settings
        saveElement.addEventListener("click", function (e) {
          const saveStatus = document.getElementById('save_status');
          if (saveStatus) saveStatus.textContent = 'Saving...';
          // Note: Save remains enabled; we validate progressively and only block
          // when an entered value is outside allowed bounds (handled per-field below).
          // Save all settings
          if (melcloudUserElement) persistSetting('melcloud_user', melcloudUserElement.value, { trimString: true });

          if (melcloudPassElement) persistSetting('melcloud_pass', melcloudPassElement.value);

          // Save device and building IDs based on selection or manual entry
          if (showManualEntryElement && showManualEntryElement.checked && manualDeviceIdElement && manualDeviceIdElement.value) {
            persistSetting('device_id', manualDeviceIdElement.value, { trimString: true });

            const manualBuildingId = parseInt(manualBuildingIdElement ? manualBuildingIdElement.value : '0', 10);
            persistSetting('building_id', Number.isFinite(manualBuildingId) ? manualBuildingId : 0);
          } else {
            if (deviceIdElement) persistSetting('device_id', deviceIdElement.value, { trimString: true });

            const selectedBuildingId = parseInt(buildingIdElement ? buildingIdElement.value : '0', 10);
            persistSetting('building_id', Number.isFinite(selectedBuildingId) ? selectedBuildingId : 0);
          }

          // Do not persist UI-only manual entry settings

          if (tibberTokenElement) persistSetting('tibber_token', tibberTokenElement.value, { trimString: true });

          // Save costs & consumption
          if (gridFeeElement) {
            (function() {
              const gf = parseFloat(gridFeeElement.value);
              if (!isNaN(gf) && gf >= 0) {
                Homey.set("grid_fee_per_kwh", gf, function (err) { if (err) console.error('Error saving grid_fee_per_kwh:', err); });
              } else if (gridFeeElement.value === "") {
                Homey.set("grid_fee_per_kwh", 0, function (err) { if (err) console.error('Error saving grid_fee_per_kwh:', err); });
              } else {
                return Homey.alert('Invalid grid fee. Must be a non-negative number.');
              }
            })();
          }

          if (tempStepMaxElement) {
            const tempStepMax = parseFloat(tempStepMaxElement.value);
            if (!isNaN(tempStepMax) && (tempStepMax === 0.5 || tempStepMax === 1.0)) {
              Homey.set("temp_step_max", tempStepMax, function (err) {
                if (err) console.error('Error saving temp_step_max:', err);
              });
            } else if (tempStepMaxElement.value) {
              Homey.alert('Invalid temperature step value. Must be 0.5 or 1.0 degrees.');
              return;
            }
          }

          if (logLevelElement) {
            Homey.set("log_level", parseInt(logLevelElement.value), function (err) {
              if (err) console.error('Error saving log_level:', err);
            });
          }

          if (notifyOnSuccessElement) {
            Homey.set("notify_on_success", notifyOnSuccessElement.checked, function (err) {
              if (err) console.error('Error saving notify_on_success:', err);
            });
          }

          if (timelineVerbosityElement) {
            Homey.set("timeline_verbosity", timelineVerbosityElement.value, function (err) {
              if (err) console.error('Error saving timeline_verbosity:', err);
            });
          }

          // Save currency code (optional)
          if (currencyCodeElement) {
            const code = (currencyCodeElement.value || '').trim();
            if (code) {
              const normalized = code.toUpperCase();
              if (/^[A-Z]{3}$/.test(normalized)) {
                persistSetting('currency', normalized);
              } else {
                Homey.alert('Invalid currency code. Use a 3-letter ISO code like NOK, SEK, EUR.');
                return;
              }
            } else {
              // Clear custom currency if input empty
              persistSetting('currency', null);
            }
          }

          if (useWeatherDataElement) {
            Homey.set("use_weather_data", useWeatherDataElement.checked, function (err) {
              if (err) console.error('Error saving use_weather_data:', err);
            });
          }

          // Save location settings
          if (latitudeElement) {
            const latitude = parseFloat(latitudeElement.value);
            if (!isNaN(latitude) && latitude >= -90 && latitude <= 90) {
              Homey.set("latitude", latitude, function (err) {
                if (err) console.error('Error saving latitude:', err);
              });
            } else if (latitudeElement.value) {
              Homey.alert('Invalid latitude value. Must be between -90 and 90.');
              return;
            }
          }

          if (longitudeElement) {
            const longitude = parseFloat(longitudeElement.value);
            if (!isNaN(longitude) && longitude >= -180 && longitude <= 180) {
              Homey.set("longitude", longitude, function (err) {
                if (err) console.error('Error saving longitude:', err);
              });
            } else if (longitudeElement.value) {
              Homey.alert('Invalid longitude value. Must be between -180 and 180.');
              return;
            }
          }

          // Save comfort profile settings
          if (dayStartHourElement) {
            const dayStartHour = parseInt(dayStartHourElement.value);
            if (!isNaN(dayStartHour) && dayStartHour >= 0 && dayStartHour <= 23) {
              Homey.set("day_start_hour", dayStartHour, function (err) {
                if (err) console.error('Error saving day_start_hour:', err);
              });
            }
          }

          if (dayEndHourElement) {
            const dayEndHour = parseInt(dayEndHourElement.value);
            if (!isNaN(dayEndHour) && dayEndHour >= 0 && dayEndHour <= 23) {
              Homey.set("day_end_hour", dayEndHour, function (err) {
                if (err) console.error('Error saving day_end_hour:', err);
              });
            }
          }

          if (nightTempReductionElement) {
            const nightTempReduction = parseFloat(nightTempReductionElement.value);
            if (!isNaN(nightTempReduction) && nightTempReduction >= 0 && nightTempReduction <= 5) {
              Homey.set("night_temp_reduction", nightTempReduction, function (err) {
                if (err) console.error('Error saving night_temp_reduction:', err);
              });
            }
          }

          if (preHeatHoursElement) {
            const preHeatHours = parseFloat(preHeatHoursElement.value);
            if (!isNaN(preHeatHours) && preHeatHours >= 0 && preHeatHours <= 3) {
              Homey.set("pre_heat_hours", preHeatHours, function (err) {
                if (err) console.error('Error saving pre_heat_hours:', err);
              });
            }
          }

          // Save time zone settings
          if (timeZoneOffsetElement) {
            const timeZoneOffset = parseFloat(timeZoneOffsetElement.value);
            if (!isNaN(timeZoneOffset) && timeZoneOffset >= -12 && timeZoneOffset <= 14) {
              Homey.set("time_zone_offset", timeZoneOffset, function (err) {
                if (err) console.error('Error saving time_zone_offset:', err);
              });
            }
          }

          if (useDstElement) {
            Homey.set("use_dst", useDstElement.checked, function (err) {
              if (err) console.error('Error saving use_dst:', err);
            });
          }

          if (timeZoneNameElement) {
            const tzName = (timeZoneNameElement.value || '').trim();
            Homey.set("time_zone_name", tzName || null, function (err) {
              if (err) console.error('Error saving time_zone_name:', err);
            });
          }

          // Save COP settings
          if (copWeightElement) {
            const copWeight = parseFloat(copWeightElement.value);
            if (!isNaN(copWeight) && copWeight >= 0.0 && copWeight <= 1.0) {
              Homey.set("cop_weight", copWeight, function (err) {
                if (err) console.error('Error saving cop_weight:', err);
              });
            } else if (copWeightElement.value) {
              Homey.alert('Invalid COP weight value. Must be between 0.0 and 1.0.');
              return;
            }
          }

          if (autoSeasonalModeElement) {
            Homey.set("auto_seasonal_mode", autoSeasonalModeElement.checked, function (err) {
              if (err) console.error('Error saving auto_seasonal_mode:', err);
            });
          }

          if (summerModeElement) {
            Homey.set("summer_mode", summerModeElement.checked, function (err) {
              if (err) console.error('Error saving summer_mode:', err);
            });
          }

          if (deadbandElement) {
            const deadband = parseFloat(deadbandElement.value);
            if (!isNaN(deadband) && deadband >= 0.1 && deadband <= 2.0) {
              Homey.set("deadband_c", deadband, function (err) { if (err) console.error('Error saving deadband_c:', err); });
            } else if (deadbandElement.value) { Homey.alert('Invalid Deadband. 0.1‚Äì2.0¬∞C'); return; }
          }

          if (minChangeMinutesElement) {
            const minChange = parseInt(minChangeMinutesElement.value);
            if (!isNaN(minChange) && minChange >= 5 && minChange <= 180) {
              Homey.set("min_setpoint_change_minutes", minChange, function (err) { if (err) console.error('Error saving min_setpoint_change_minutes:', err); });
            } else if (minChangeMinutesElement.value) { Homey.alert('Invalid Min Setpoint Interval. 5‚Äì180 min'); return; }
          }

          if (extremeMinElement) {
            const extremeMin = parseFloat(extremeMinElement.value);
            if (!isNaN(extremeMin) && extremeMin >= 16 && extremeMin <= 23) {
              Homey.set("extreme_weather_min_temp", extremeMin, function (err) { if (err) console.error('Error saving extreme_weather_min_temp:', err); });
            } else if (extremeMinElement.value) { Homey.alert('Invalid Extreme Cold Min. 16‚Äì23¬∞C'); return; }
          }

          if (occupiedElement) {
            Homey.set("occupied", occupiedElement.checked, function (err) { if (err) console.error('Error saving occupied:', err); });
          }

          if (comfortLowerOccElement && comfortUpperOccElement) {
            const clo = parseFloat(comfortLowerOccElement.value);
            const cuo = parseFloat(comfortUpperOccElement.value);
            if (!isNaN(clo) && !isNaN(cuo) && clo >= 18 && clo <= 23 && cuo >= 19 && cuo <= 24 && clo < cuo) {
              Homey.set("comfort_lower_occupied", clo, function (err) { if (err) console.error('Error saving comfort_lower_occupied:', err); });
              Homey.set("comfort_upper_occupied", cuo, function (err) { if (err) console.error('Error saving comfort_upper_occupied:', err); });
            } else if (comfortLowerOccElement.value || comfortUpperOccElement.value) { Homey.alert('Invalid Occupied band. Lower 18‚Äì23, Upper 19‚Äì24, Lower < Upper'); return; }
          }

          if (comfortLowerAwayElement && comfortUpperAwayElement) {
            const cla = parseFloat(comfortLowerAwayElement.value);
            const cua = parseFloat(comfortUpperAwayElement.value);
            if (!isNaN(cla) && !isNaN(cua) && cla >= 17 && cla <= 22 && cua >= 18 && cua <= 23 && cla < cua) {
              Homey.set("comfort_lower_away", cla, function (err) { if (err) console.error('Error saving comfort_lower_away:', err); });
              Homey.set("comfort_upper_away", cua, function (err) { if (err) console.error('Error saving comfort_upper_away:', err); });
            } else if (comfortLowerAwayElement.value || comfortUpperAwayElement.value) { Homey.alert('Invalid Away band. Lower 17‚Äì22, Upper 18‚Äì23, Lower < Upper'); return; }
          }

          if (preheatEnableElement) {
            Homey.set("preheat_enable", preheatEnableElement.checked, function (err) { if (err) console.error('Error saving preheat_enable:', err); });
          }
          
          if (preheatHorizonElement) {
            const horizon = parseInt(preheatHorizonElement.value);
            if (!isNaN(horizon) && horizon >= 6 && horizon <= 36) {
              Homey.set("preheat_horizon_hours", horizon, function (err) { if (err) console.error('Error saving preheat_horizon_hours:', err); });
            } else if (preheatHorizonElement.value) { Homey.alert('Invalid horizon. 6‚Äì36h'); return; }
          }
          
          if (preheatPercentileElement) {
            const pct = parseFloat(preheatPercentileElement.value);
            if (!isNaN(pct) && pct >= 0.05 && pct <= 0.5) {
              Homey.set("preheat_cheap_percentile", pct, function (err) { if (err) console.error('Error saving preheat_cheap_percentile:', err); });
            } else if (preheatPercentileElement.value) { Homey.alert('Invalid cheap percentile. 0.05‚Äì0.5'); return; }
          }

          // Save hot water tank settings
          if (enableTankControlElement) {
            Homey.set("enable_tank_control", enableTankControlElement.checked, function (err) {
              if (err) console.error('Error saving enable_tank_control:', err);
            });
          }

          let minTankTemp = NaN;
          if (minTankTempElement) {
            minTankTemp = parseFloat(minTankTempElement.value);
            if (!isNaN(minTankTemp) && minTankTemp >= 30 && minTankTemp <= 45 && minTankTemp === Math.round(minTankTemp)) {
              Homey.set("min_tank_temp", minTankTemp, function (err) {
                if (err) console.error('Error saving min_tank_temp:', err);
              });
            } else if (minTankTempElement.value) {
              Homey.alert('Invalid minimum tank temperature value. Must be a whole number between 30 and 45.');
              return;
            }
          }

          let maxTankTemp = NaN;
          if (maxTankTempElement) {
            maxTankTemp = parseFloat(maxTankTempElement.value);
            if (!isNaN(maxTankTemp) && maxTankTemp >= 40 && maxTankTemp <= 60 && maxTankTemp === Math.round(maxTankTemp)) {
              Homey.set("max_tank_temp", maxTankTemp, function (err) {
                if (err) console.error('Error saving max_tank_temp:', err);
              });
            } else if (maxTankTempElement.value) {
              Homey.alert('Invalid maximum tank temperature value. Must be a whole number between 40 and 60.');
              return;
            }
          }

          // Validate min < max for tank temperature
          if (!isNaN(minTankTemp) && !isNaN(maxTankTemp) && minTankTemp >= maxTankTemp) {
            Homey.alert('Minimum tank temperature must be less than maximum tank temperature.');
            return;
          }

          if (tankTempStepElement) {
            const tankTempStep = parseFloat(tankTempStepElement.value);
            if (!isNaN(tankTempStep) && tankTempStep >= 1.0 && tankTempStep <= 5.0 && tankTempStep === Math.round(tankTempStep)) {
              Homey.set("tank_temp_step", tankTempStep, function (err) {
                if (err) console.error('Error saving tank_temp_step:', err);
              });
            } else if (tankTempStepElement.value) {
              Homey.alert('Invalid tank temperature step value. Must be a whole number between 1 and 5 degrees.');
              return;
            }
          }
          
          // Removed: persistence for unused hot water pattern settings

          // Save Zone2 settings
          if (enableZone2Element) {
            Homey.set("enable_zone2", enableZone2Element.checked, function (err) {
              if (err) console.error('Error saving enable_zone2:', err);
            });
          }

          let minTempZone2 = NaN;
          if (minTempZone2Element) {
            minTempZone2 = parseFloat(minTempZone2Element.value);
            if (!isNaN(minTempZone2) && minTempZone2 >= 16 && minTempZone2 <= 22) {
              Homey.set("min_temp_zone2", minTempZone2, function (err) {
                if (err) console.error('Error saving min_temp_zone2:', err);
              });
            } else if (minTempZone2Element.value) {
              Homey.alert('Invalid minimum Zone2 temperature value. Must be between 16 and 22.');
              return;
            }
          }

          let maxTempZone2 = NaN;
          if (maxTempZone2Element) {
            maxTempZone2 = parseFloat(maxTempZone2Element.value);
            if (!isNaN(maxTempZone2) && maxTempZone2 >= 20 && maxTempZone2 <= 26) {
              Homey.set("max_temp_zone2", maxTempZone2, function (err) {
                if (err) console.error('Error saving max_temp_zone2:', err);
              });
            } else if (maxTempZone2Element.value) {
              Homey.alert('Invalid maximum Zone2 temperature value. Must be between 20 and 26.');
              return;
            }
          }

          // Validate min < max for Zone2 temperature
          if (!isNaN(minTempZone2) && !isNaN(maxTempZone2) && minTempZone2 >= maxTempZone2) {
            Homey.alert('Minimum Zone2 temperature must be less than maximum Zone2 temperature.');
            return;
          }

          if (tempStepZone2Element) {
            const tempStepZone2 = parseFloat(tempStepZone2Element.value);
            if (!isNaN(tempStepZone2) && tempStepZone2 >= 0.1 && tempStepZone2 <= 2.0) {
              Homey.set("temp_step_zone2", tempStepZone2, function (err) {
                if (err) console.error('Error saving temp_step_zone2:', err);
              });
            } else if (tempStepZone2Element.value) {
              Homey.alert('Invalid Zone2 temperature step value. Must be between 0.1 and 2.0.');
              return;
            }
          }

          // Show success message
          if (saveStatus) saveStatus.textContent = 'Saved successfully';
          
          // Validate settings and start cron jobs if everything is ready
          Homey.api('GET', '/validateAndStartCron', {}, function(err, result) {
            console.log('validateAndStartCron response:', { err, result });
            if (err) {
              console.error('Error validating settings:', err);
              if (saveStatus) saveStatus.textContent = 'Settings saved, but validation failed: ' + (err.message || err);
              // Don't show alert for API errors
            } else if (result && result.success) {
              if (result.cronRunning) {
                if (saveStatus) saveStatus.textContent = 'Settings saved, optimization running ‚úÖ';
                // Success status is shown in the page, no need for popup
              } else {
                if (saveStatus) saveStatus.textContent = 'Settings saved ‚ö†Ô∏è ' + (result.message || 'Please complete required settings');
                // Status is shown in the page, no need for popup
              }
            } else {
              console.error('Unexpected validateAndStartCron result:', result);
              if (saveStatus) saveStatus.textContent = 'Settings saved, validation failed';
              // Don't show alert for validation failures
            }
          });
        });

        // Button event handlers are now defined as global functions and attached via onclick attributes
      }
      
      // After Homey has likely populated inputs, run validation once more
      setTimeout(function(){
        try {
          var btn = document.getElementById('save');
          // If available, try to validate and potentially enable Save
          if (btn && typeof window !== 'undefined') {
            var evt = document.createEvent ? document.createEvent('Event') : null;
            if (evt && evt.initEvent) { evt.initEvent('input', true, true); document.dispatchEvent(evt); }
            if (typeof validateAll === 'function') validateAll();
          }
        } catch (_) { /* ignore */ }
      }, 300);

      // Inline validation helpers and progressive disclosure helpers
      (function attachValidation() {
        function setError(input, msg) {
          if (!input) return;
          input.setAttribute('aria-invalid', 'true');
          let err = input.nextElementSibling;
          if (!err || !err.classList || !err.classList.contains('homey-form-error')) {
            err = document.createElement('p');
            err.className = 'homey-form-error';
            input.insertAdjacentElement('afterend', err);
          }
          err.textContent = msg;
        }
        function clearError(input) {
          if (!input) return;
          input.removeAttribute('aria-invalid');
          const err = input.nextElementSibling;
          if (err && err.classList && err.classList.contains('homey-form-error')) err.remove();
        }
        function validateRange(lowerEl, upperEl, name) {
          const loStr = lowerEl ? String(lowerEl.value || '') : '';
          const hiStr = upperEl ? String(upperEl.value || '') : '';
          const lo = parseFloat(loStr);
          const hi = parseFloat(hiStr);

          // If both empty (or not numbers), do not show error and treat as neutral OK
          const loMissing = loStr === '' || isNaN(lo);
          const hiMissing = hiStr === '' || isNaN(hi);
          if (loMissing && hiMissing) {
            clearError(lowerEl); clearError(upperEl); return true;
          }

          // If one is missing while the user is typing or values are still loading,
          // do not show error yet, but block Save by returning false.
          if (loMissing || hiMissing) {
            clearError(lowerEl); clearError(upperEl); return false;
          }

          // Both numbers present ‚Äî validate ordering
          if (lo < hi) {
            clearError(lowerEl); clearError(upperEl); return true;
          }
          if (upperEl) setError(upperEl, name + ': upper must be greater than lower');
          return false;
        }
        function validateWeather(useEl, latEl, lonEl) {
          if (!useEl || !latEl || !lonEl) return true;
          if (!useEl.checked) { clearError(latEl); clearError(lonEl); return true; }
          const ok = latEl.value !== '' && lonEl.value !== '';
          if (!ok) setError(lonEl, 'Latitude and longitude required when weather is enabled');
          else { clearError(latEl); clearError(lonEl); }
          return ok;
        }
        function validateTank(minEl, maxEl, stepEl) {
          let ok = true;
          const min = parseFloat(minEl?.value);
          const max = parseFloat(maxEl?.value);
          const step = parseFloat(stepEl?.value);
          if (!(min >= 30 && min <= 45)) { setError(minEl, '30‚Äì45¬∞C'); ok = false; } else clearError(minEl);
          if (!(max >= 40 && max <= 60)) { setError(maxEl, '40‚Äì60¬∞C'); ok = false; } else clearError(maxEl);
          if (!isNaN(min) && !isNaN(max) && !(min < max)) { setError(maxEl, 'Max must be > Min'); ok = false; }
          if (!(step >= 0.5 && step <= 5.0)) { setError(stepEl, '0.5‚Äì5.0¬∞C'); ok = false; } else clearError(stepEl);
          return ok;
        }
        function validateAll() {
          const ok1 = validateRange(
            document.getElementById('comfort_lower_occupied'),
            document.getElementById('comfort_upper_occupied'),
            'Occupied band'
          );
          const ok2 = validateRange(
            document.getElementById('comfort_lower_away'),
            document.getElementById('comfort_upper_away'),
            'Away band'
          );
          const ok3 = validateWeather(
            document.getElementById('use_weather_data'),
            document.getElementById('latitude'),
            document.getElementById('longitude')
          );
          const ok4 = validateTank(
            document.getElementById('min_tank_temp'),
            document.getElementById('max_tank_temp'),
            document.getElementById('tank_temp_step')
          );
          return ok1 && ok2 && ok3 && ok4;
        }
        ['comfort_lower_occupied','comfort_upper_occupied','comfort_lower_away','comfort_upper_away','use_weather_data','latitude','longitude','min_tank_temp','max_tank_temp','tank_temp_step']
          .forEach(id => document.getElementById(id)?.addEventListener('input', validateAll));
        // Run once now to enable Save if defaults are valid
        try { validateAll(); } catch (_) {}
        // Also run after DOMContentLoaded in case script loads early
        document.addEventListener('DOMContentLoaded', function () { try { validateAll(); } catch (_) {} });
      })();
      
      // Hot water usage pattern functions
      function viewHotWaterPatterns() {
        const resultElement = document.getElementById('hot_water_action_result');
        resultElement.textContent = 'Retrieving hot water usage patterns...';
        
        Homey.api('GET', '/hot-water/patterns', {}, function(err, result) {
          if (err) {
            resultElement.textContent = 'Error: ' + (err.message || 'Failed to retrieve patterns');
            return;
          }
          resultElement.textContent = result.message || 'Hot water usage patterns retrieved - check the terminal/logs!';
        });
      }
      
      function resetHotWaterPatterns() {
        const resultElement = document.getElementById('hot_water_action_result');
        resultElement.textContent = 'Resetting hot water usage patterns...';
        
        Homey.api('POST', '/hot-water/reset-patterns', {}, function(err, result) {
          if (err) {
            resultElement.textContent = 'Error: ' + (err.message || 'Failed to reset patterns');
            return;
          }
          resultElement.textContent = 'Hot water usage patterns have been reset to defaults.';
        });
      }
      
      function clearHotWaterData(keepAggregated = false) {
        const actionText = keepAggregated ? 
          'clear detailed hot water usage data but keep aggregated patterns' : 
          'clear ALL hot water usage data including patterns';
        
        if (confirm(`Are you sure you want to ${actionText}? This action cannot be undone.`)) {
          const resultElement = document.getElementById('hot_water_action_result');
          resultElement.textContent = `Clearing hot water usage data${keepAggregated ? ' (keeping aggregated data)' : ''}...`;
          
          Homey.api('POST', '/hot-water/clear-data', { clearAggregated: !keepAggregated }, function(err, result) {
            if (err) {
              resultElement.textContent = 'Error: ' + (err.message || 'Failed to clear data');
              return;
            }
            resultElement.textContent = result.message || 'Hot water usage data has been cleared.';
          });
        }
      }
    </script>
    <script>
      (function () {
        function enhanceTooltips(root) {
          const nodes = root.querySelectorAll('[data-tooltip]:not([data-tt-init])');
          nodes.forEach(node => {
            node.setAttribute('data-tt-init', '1');
            const wrap = document.createElement('span');
            wrap.className = 'tt-wrap';
            if (node.parentNode) {
              node.parentNode.insertBefore(wrap, node);
            }
            wrap.appendChild(node);

            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'tt-btn';
            btn.setAttribute('aria-label', 'Info');
            btn.textContent = 'i';

            const bubble = document.createElement('span');
            bubble.className = 'tt-bubble';
            bubble.setAttribute('role', 'tooltip');
            bubble.textContent = node.getAttribute('data-tooltip') || '';

            wrap.appendChild(btn);
            wrap.appendChild(bubble);

            btn.addEventListener('click', (event) => {
              event.stopPropagation();
              const isOpen = wrap.getAttribute('data-open') === 'true';
              document.querySelectorAll('.tt-wrap[data-open="true"]').forEach(other => {
                other.setAttribute('data-open', 'false');
              });
              wrap.setAttribute('data-open', isOpen ? 'false' : 'true');
            });
          });
        }

        document.addEventListener('click', () => {
          document.querySelectorAll('.tt-wrap[data-open="true"]').forEach(wrap => {
            wrap.setAttribute('data-open', 'false');
          });
        });

        enhanceTooltips(document);

        window.attachTooltips = () => enhanceTooltips(document);
      })();
    </script>
  </body>
</html>
